<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StudyBuddy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        * { box-sizing: border-box; } /* More predictable box model */
        /* General Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f9ff; /* Tailwind sky-50 */
            overscroll-behavior-y: contain; 
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }
        .card {
            background-color: white;
            border-radius: 0.75rem; 
            padding: 1.5rem; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); 
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem; 
            font-weight: 600; 
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: 1px solid transparent;
            user-select: none; /* Prevent text selection on buttons */
        }
        .btn:active { /* Subtle feedback on tap */
            transform: scale(0.98);
        }
        .btn-primary { background-color: #0d9488; color: white; }
        .btn-primary:hover { background-color: #0f766e; box-shadow: 0 2px 10px -1px rgba(13, 148, 136, 0.5); }
        .btn-secondary { background-color: #475569; color: white; }
        .btn-secondary:hover { background-color: #334155; }
        .btn-outline { border-color: #0d9488; color: #0d9488; }
        .btn-outline:hover { background-color: #ccfbf1; color: #0f766e; }
        .btn-warning { background-color: #f59e0b; color: white; }
        .btn-warning:hover { background-color: #d97706; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover { background-color: #b91c1c; }

        /* --- New Google Login Button Style --- */
        .btn-google {
            background-color: #ffffff;
            color: #374151; /* gray-700 */
            border: 1px solid #d1d5db; /* gray-300 */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem; /* space between icon and text */
        }
        .btn-google:hover {
            background-color: #f9fafb; /* gray-50 */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        .google-icon {
            width: 1.25rem;
            height: 1.25rem;
        }

        /* Game Specific Styles */
        .game-card {
            min-height: 150px; display: flex; align-items: center; justify-content: center;
            text-align: center; cursor: pointer; border: 1px solid #99f6e4; 
            overflow-wrap: break-word; word-break: break-word;
        }
        .selected-match { border: 2px solid #0d9488; background-color: #f0fdfa; }
        .matched { opacity: 0.4; pointer-events: none; background-color: #a7f3d0; border-color: #34d399; }
        .incorrect-match-animation { animation: shake 0.4s; border: 2px solid #ef4444 !important; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-6px); } 75% { transform: translateX(6px); } }

        .mcq-option-btn, .part-selection-btn, .essentials-category-btn, .essentials-action-btn {
            display: block; width: 100%; text-align: left; margin-bottom: 0.5rem;
            background-color: #f8fafc; border: 1px solid #cbd5e1; color: #334155;
            white-space: normal; overflow: hidden; text-overflow: ellipsis; padding: 0.75rem 1rem;
        }
        .mcq-option-btn:hover, .part-selection-btn:hover, .essentials-category-btn:hover, .essentials-action-btn:hover {
            background-color: #f1f5f9; border-color: #94a3b8;
        }
        #mcqQuestion.speakable-question:hover { cursor: pointer; background-color: #e0f2f7; }
        .correct-answer { background-color: #d1fae5 !important; border-color: #6ee7b7 !important; color: #065f46 !important; }
        .incorrect-answer { background-color: #fee2e2 !important; border-color: #fca5a5 !important; color: #991b1b !important; }
        .stack-selection-btn { background-color: #eef2ff; color: #4338ca; border: 1px solid #c7d2fe; }
        .stack-selection-btn:hover { background-color: #e0e7ff; }

        /* UI Elements */
        #musicToggleBtn { position: fixed; top: 1rem; right: 1rem; z-index: 1000; background-color: rgba(255,255,255,0.7); backdrop-filter: blur(4px); border: 1px solid #99f6e4; color: #0d9488; }
        .capybara-life-icon { width: 2rem; height: 2rem; color: #8d5524; transition: opacity 0.3s ease, transform 0.3s ease; vertical-align: middle; }
        .capybara-life-icon.mistake { opacity: 0.3; transform: scale(0.75) rotate(-8deg) translateX(2px); color: #a1a1aa; }
        #gameInfoBar {
            display: flex;
            justify-content: space-between;
            align-items: center; /* Center items vertically */
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background-color: #f8fafc;
            border-radius: 0.375rem;
            flex-wrap: wrap; 
            gap: 0.5rem; 
        }
        #mistakeTracker { display: flex; gap: 0.5rem; flex-shrink: 0; }
        #scoreDisplayContainer { display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0; margin-left: auto; /* Push to right if space allows */ }
        #currentScoreDisplay { font-size: 1.125rem; font-weight: 600; color: #0d9488; }
        #maxScoreDisplay { font-size: 0.875rem; color: #0f766e;}
        .truncate-text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; max-width: 100%; }
        #roundCompleteMessage, #bonusRoundCountdownMessage { text-align: center; font-size: 1.5rem; font-weight: 600; color: #0d9488; padding: 2rem; border: 2px dashed #99f6e4; border-radius: 0.5rem; margin-top: 1rem; }

        #talkToMePhraseToRead { min-height: 80px; padding-bottom: 2.5rem; position: relative; }
        #talkToMeRecognizedText, #talkToMeReferenceDisplay { min-height: 40px; }
        #speakPhraseBtn { position: absolute; bottom: 0.5rem; left: 50%; transform: translateX(-50%); padding: 0.3rem; background-color: rgba(255,255,255,0.5); }
        #speakPhraseBtn svg { width: 1.25rem; height: 1.25rem; color: #0d9488; }
        #listenBtn.listening { background-color: #ef4444; color: white; }
        #listenBtn.listening:hover { background-color: #dc2626; }

        .header-logo-image { max-width: 120px; height: auto; margin: 0 auto; }
        #hearItOutLoudToggleBtn.active { background-color: #0d9488; color: white; }

        .selected-find-word { background-color: #cffafe !important; border-color: #67e8f9 !important; outline: 2px solid #06b6d4; }

        #fillInTheBlanksSentence.speakable-question:hover { cursor: pointer; background-color: #e0f2f7; }
        .blank-input { border-bottom: 2px solid #0d9488; padding: 0.25rem 0.5rem; margin: 0 0.25rem; background-color: transparent; text-align: center; min-width: 80px; }
        #fillInTheBlanksSentence .blank-placeholder { display: inline-block; width: 100px; border-bottom: 1px solid #334155; text-align: center; font-style: italic; color: #64748b; }

        #targetLanguageSelectorContainer { margin-bottom: 1rem; }
        #targetLanguageSelector, #languageSelectorInGame { 
            padding: 0.5rem; font-size: 0.875rem; border: 1px solid #cbd5e1;
            border-radius: 0.375rem; width: auto; 
        }
        #targetLanguageSelector:focus, #languageSelectorInGame:focus {
            outline: 2px solid transparent; outline-offset: 2px;
            border-color: #0d9488; box-shadow: 0 0 0 2px #0d9488;
        }
        #languageSelectionInGameContainer {
            display: flex; align-items: center; 
            flex-grow: 1; /* Allow it to take available space */
            flex-shrink: 1; /* Allow it to shrink */
            min-width: 130px; /* Give it a minimum width to prevent excessive squishing */
            margin-right: 0.5rem; /* Space before next item if wrapped */
        }
        #languageSelectionInGameContainer label {
            margin-right: 0.5rem; font-size: 0.875rem; color: #334155; white-space: nowrap;
        }
        #hearItOutLoudToggleBtn {
            flex-shrink: 0; /* Don't let this button shrink too much */
        }
        /* Drag and Drop Area */
        #dropZone {
            border: 3px dashed #99f6e4; /* Tailwind teal-200 */
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            padding: 2rem;
            text-align: center;
            color: #0f766e; /* Tailwind teal-700 */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            margin-top: 1rem;
        }
        #dropZone.dragover-active {
            background-color: #ccfbf1; /* Tailwind teal-100 */
            border-color: #0d9488; /* Tailwind teal-600 */
        }
        
        /* New Login Form Styles */
        .form-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.5rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .form-input:focus {
            outline: none;
            border-color: #0d9488;
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }
        .toggle-auth-link {
            color: #0d9488;
            cursor: pointer;
            text-decoration: underline;
        }

        /* Mobile Specific Adjustments */
        @media (max-width: 420px) { /* Slightly wider breakpoint for these general adjustments */
            .card {
                padding: 1rem; 
            }
            .game-card { 
                min-height: 100px; 
                padding: 0.5rem;  
                font-size: 0.875rem; 
            }
            #matchingGrid {
                gap: 0.5rem; 
            }
            .mcq-option-btn {
                padding: 0.6rem 0.8rem; 
                font-size: 0.875rem;
            }
            #mcqQuestion {
                min-height: 60px;
                font-size: 1rem;
            }

            #gameInfoBar {
                padding: 0.35rem;
                gap: 0.35rem;
            }
            #languageSelectionInGameContainer {
                min-width: 120px; 
                margin-left: 0.25rem;
            }
            #languageSelectionInGameContainer label,
            #languageSelectorInGame {
                font-size: 0.75rem; 
            }
            #languageSelectorInGame {
                padding: 0.35rem 0.25rem; /* More padding reduction */
                max-width: 120px; /* Prevent dropdown from becoming too wide */
            }
            #currentScoreDisplay {
                font-size: 1rem;
            }
            #maxScoreDisplay {
                font-size: 0.75rem;
            }
             #mistakeTracker {
                gap: 0.25rem; 
            }
            .capybara-life-icon {
                width: 1.5rem; height: 1.5rem;
            }
            #hearItOutLoudToggleBtn {
                padding: 0.25rem 0.5rem;
                font-size: 0.7rem;
            }
            #hearItOutLoudToggleBtn svg {
                width: 0.8rem; height: 0.8rem;
            }
            #gameHeader h2 { 
                font-size: 1.25rem; 
            }
            #gameHeader button { 
                padding: 0.25rem 0.5rem;
                font-size: 0.75rem;
            }
            .btn { 
                padding: 0.6rem 1rem;
                font-size: 0.875rem;
            }
            #mainSelectionSection .btn, #uploadSection .btn, #essentialsCategorySelectionSection .btn, #essentialsCategoryOptionsSection .btn, #gameSelectionSection .btn {
                padding: 0.75rem; 
                font-size: 0.9rem;
            }
            #dropZone {
                padding: 1rem;
                font-size: 0.9rem;
            }
        }
        @media (max-width: 360px) { /* For very small screens */
            #languageSelectionInGameContainer {
                flex-basis: 100%; /* Make speech selector take full width if it wraps */
                margin-left: 0;
                margin-right: 0;
            }
            #languageSelectorInGame {
                width: 100%; /* Make dropdown full width within its container */
                max-width: none;
            }
            #hearItOutLoudToggleBtn {
                font-size: 0.65rem;
                padding: 0.2rem 0.4rem;
            }
             #gameInfoBar {
                justify-content: center; /* Center items if they all wrap */
            }
             #scoreDisplayContainer {
                margin-left: 0; /* Reset margin if centered */
                align-items: center;
            }
        }

    </style>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="min-h-screen flex flex-col items-center p-2 sm:p-4 md:p-6">

    <button id="musicToggleBtn" class="btn p-2 text-sm">
        <svg id="musicIconOn" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15z" /></svg>
        <svg id="musicIconOff" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15zM17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"/></svg>
        <span id="musicStatusText">Music: ON</span>
    </button>

    <div class="w-full max-w-3xl mx-auto"> 
        <header class="text-center mb-6 sm:mb-10">
            <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh7G7JZO-izPezsiQzlGVi10doRtWHuCKsp3u9txVRurU_ziVdRHtF5XswySzXYQMbLpJXCr3QvXSrSQdJIuzO9QeNIkjUKqHIayQZQUFQFP2bpmVr_5auHdT-lbCL8KaVkrjrbw5UJqJApeGTADnBy-r5G-CBhHOGsvuAy8cN7FyJxH8VrJHM2Bu4TqZo/s512/studybuddy.jpg" alt="StudyBuddy Logo" class="header-logo-image"
                 onerror="this.onerror=null; this.src='https://placehold.co/120x80/CCCCCC/000000?text=Logo';">
            <p class="text-2xl sm:text-3xl font-bold text-teal-700 mt-2">StudyBuddy</p>
            <p class="text-lg sm:text-xl text-teal-600 mt-1">Your fun way to master vocabulary!</p>
        </header>

        <!-- New Login Section -->
        <section id="loginSection" class="card mb-8">
            <h2 id="authTitle" class="text-2xl font-semibold text-teal-700 mb-4 text-center">Login to Your Account</h2>
            
            <form id="authForm" class="space-y-4">
                <div>
                    <label for="emailInput" class="block text-sm font-medium text-gray-700">Email Address</label>
                    <input type="email" id="emailInput" class="form-input mt-1" required>
                </div>
                <div>
                    <label for="passwordInput" class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="passwordInput" class="form-input mt-1" required>
                </div>
                <button type="submit" id="authSubmitBtn" class="btn btn-primary w-full p-3 text-lg">Login</button>
            </form>
            <p id="authError" class="text-red-500 text-sm text-center mt-2 h-5"></p>

            <div class="relative my-6">
                <div class="absolute inset-0 flex items-center" aria-hidden="true"><div class="w-full border-t border-gray-300"></div></div>
                <div class="relative flex justify-center"><span class="bg-white px-2 text-sm text-gray-500">or</span></div>
            </div>

            <button id="googleLoginBtn" class="btn btn-google w-full p-4 text-lg">
                <svg class="google-icon" viewBox="0 0 48 48" aria-hidden="true"><path fill="#4285F4" d="M45.12 24.5c0-1.56-.14-3.06-.4-4.5H24v8.51h11.84c-.51 2.75-2.06 5.08-4.39 6.64v5.52h7.11c4.16-3.83 6.56-9.47 6.56-16.17z"></path><path fill="#34A853" d="M24 46c6.48 0 11.93-2.13 15.89-5.82l-7.11-5.52c-2.17 1.45-4.92 2.3-8.78 2.3-6.76 0-12.47-4.55-14.51-10.61H2.3v5.7C6.32 40.57 14.56 46 24 46z"></path><path fill="#FBBC05" d="M9.49 27.9c-.4-1.18-.62-2.45-.62-3.79s.22-2.61.62-3.79V14.6H2.3C.83 17.53 0 20.65 0 24.11s.83 6.58 2.3 9.51l7.19-5.72z"></path><path fill="#EA4335" d="M24 8.71c3.55 0 6.63 1.23 9.13 3.63l6.3-6.3C35.91 2.25 30.47 0 24 0 14.56 0 6.32 5.43 2.3 14.6l7.19 5.71C11.53 14.26 17.24 8.71 24 8.71z"></path></svg>
                <span>Continue with Google</span>
            </button>
            
            <p id="authToggleText" class="text-center text-sm mt-4">
                Don't have an account? <span id="toggleToSignUp" class="toggle-auth-link">Sign Up</span>
            </p>
        </section>

        <!-- Main App Content (hidden by default) -->
        <div id="appContent" class="hidden w-full">
            <div class="flex justify-end mb-4">
                <button id="logoutBtn" class="btn btn-danger text-sm py-2 px-3">Logout</button>
            </div>
            <section id="mainSelectionSection" class="card non-interactive-card mb-6 sm:mb-8">
                <h2 class="text-xl sm:text-2xl font-semibold text-teal-700 mb-4">Get Started</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                    <button id="showUploadSectionBtn" class="btn btn-primary p-4 sm:p-6 text-base sm:text-lg">Upload My Own List</button>
                    <button id="showEssentialsSectionBtn" class="btn btn-primary p-4 sm:p-6 text-base sm:text-lg">Study Essentials</button>
                </div>
            </section>

            <section id="uploadSection" class="card non-interactive-card mb-6 sm:mb-8 hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl sm:text-2xl font-semibold text-teal-700">1. Upload Vocabulary</h2>
                    <button id="backToMainSelectionFromUploadBtn" class="btn btn-secondary text-xs sm:text-sm py-1 px-2">Back</button>
                </div>
                <div class="mb-4 p-3 sm:p-4 bg-teal-50 border border-teal-200 rounded-lg text-teal-800 text-sm sm:text-base">
                    <h3 class="font-semibold">CSV File Format:</h3>
                    <ul class="list-disc list-inside ml-2 sm:ml-4 text-xs sm:text-sm">
                        <li>Must be a CSV (Comma Separated Values) file.</li>
                        <li>The first row is assumed to be headers and will be ignored.</li>
                        <li>Column 1: Word/phrase in the language you are learning.</li>
                        <li>Column 2: Translation of the word/phrase (your language).</li>
                        <li>Example (Learning Tagalog, Translation English): <code>"kumusta","hello"</code></li>
                         <li>Fields containing commas or quotes must be enclosed in double quotes (e.g., <code>"word, with comma","translation"</code>).</li>
                        <li>A double quote within a quoted field should be represented as two double quotes (e.g., <code>"word with ""quote""","translation"</code>).</li>
                    </ul>
                </div>
                <div id="targetLanguageSelectorContainer" class="my-3 sm:my-4">
                    <label for="targetLanguageSelector" class="block mb-1 sm:mb-2 text-sm font-medium text-gray-900">Select Target Language (for Column 1 words):</label>
                    <select id="targetLanguageSelector" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2 sm:p-2.5">
                        <option value="en-US" selected>English (US)</option>
                        <option value="en-GB">English (UK)</option>
                        <option value="es-ES">Español (España)</option>
                        <option value="es-MX">Español (México)</option>
                        <option value="fr-FR">Français (France)</option>
                        <option value="de-DE">Deutsch (German)</option>
                        <option value="it-IT">Italiano (Italian)</option>
                        <option value="pt-PT">Português (Portugal)</option>
                        <option value="ja-JP">日本語 (Japanese)</option>
                        <option value="ko-KR">한국어 (Korean)</option>
                        <option value="zh-CN">中文 (简体 Chinese)</option>
                        <option value="nl-NL">Nederlands (Dutch)</option>
                        <option value="ru-RU">Русский (Russian)</option>
                        <option value="ar-SA">العربية (Arabic)</option>
                        <option value="hi-IN">हिन्दी (Hindi)</option>
                        <option value="tl-PH">Tagalog (Filipino)</option>
                    </select>
                </div>
                 <label for="csvFile" class="block mb-2 text-sm font-medium text-gray-900">Select CSV File or Drag & Drop Below:</label>
                <input type="file" id="csvFile" accept=".csv" class="block w-full text-sm text-gray-900 border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none focus:border-teal-500 p-2 sm:p-2.5 mb-2">
                <div id="dropZone">
                    <p>Drag & Drop CSV File Here</p>
                    <p class="text-xs mt-1">(or click the input field above)</p>
                </div>
                <button id="uploadBtn" class="btn btn-primary mt-3 sm:mt-4 w-full sm:w-auto">Load Vocabulary from Selected File</button>
                <p id="uploadStatus" class="text-sm text-slate-500 mt-2 h-5"></p>
            </section>

            <section id="essentialsCategorySelectionSection" class="card non-interactive-card mb-6 sm:mb-8 hidden">
                 <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl sm:text-2xl font-semibold text-teal-700">Study Essentials: Select a Category</h2>
                    <button id="backToMainSelectionFromEssentialsBtn" class="btn btn-secondary text-xs sm:text-sm py-1 px-2">Back</button>
                </div>
                <div id="essentialsCategoryButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-2 sm:gap-3"></div>
            </section>

            <section id="essentialsCategoryOptionsSection" class="card non-interactive-card mb-6 sm:mb-8 hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 id="essentialsOptionsTitle" class="text-xl sm:text-2xl font-semibold text-teal-700">Category: [Name]</h2>
                    <button id="backToEssentialsCategoriesBtn" class="btn btn-secondary text-xs sm:text-sm py-1 px-2">Change Category</button>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                    <button id="reviewEssentialsCategoryBtn" class="btn btn-outline essentials-action-btn p-4 sm:p-6 text-base sm:text-lg">Review This Category</button>
                    <button id="playGamesWithEssentialsBtn" class="btn btn-outline essentials-action-btn p-4 sm:p-6 text-base sm:text-lg">Play Games with This Category</button>
                </div>
            </section>

            <section id="gameSelectionSection" class="card non-interactive-card mb-6 sm:mb-8 hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl sm:text-2xl font-semibold text-teal-700">2. Select a Game</h2>
                    <button id="backToSourceSelectionBtn" class="btn btn-secondary text-xs sm:text-sm py-1 px-2">Back</button>
                </div>
                <div id="gameButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                    <button id="flashcardsBtn" class="btn btn-outline p-4 sm:p-6 text-base sm:text-lg">Flashcards</button>
                    <button id="matchingBtn" class="btn btn-outline p-4 sm:p-6 text-base sm:text-lg">Matching Game</button>
                    <button id="multipleChoiceBtn" class="btn btn-outline p-4 sm:p-6 text-base sm:text-lg">Multiple Choice</button>
                    <button id="typeTranslationBtn" class="btn btn-outline p-4 sm:p-6 text-base sm:text-lg">Type Translation</button>
                    <button id="talkToMeBtn" class="btn btn-outline p-4 sm:p-6 text-base sm:text-lg">Talk to Me (Speak)</button>
                    <button id="fillInTheBlanksBtn" class="btn btn-outline p-4 sm:p-6 text-base sm:text-lg hidden">Fill in the Blanks</button>
                    <button id="findTheWordsBtn" class="btn btn-outline p-4 sm:p-6 text-base sm:text-lg">Find the Words</button>
                </div>
            </section>

            <section id="gameArea" class="card non-interactive-card hidden">
                <div id="gameHeader" class="flex justify-between items-center mb-2">
                     <h2 id="gameTitle" class="text-xl sm:text-2xl md:text-3xl font-semibold text-teal-700">Game</h2>
                     <button id="backToGameSelectionBtn" class="btn btn-secondary text-xs sm:text-sm py-1.5 px-2 sm:py-2 sm:px-3">Back to Games</button>
                </div>
                <div id="gameInfoBar">
                    <div class="flex items-center space-x-1 sm:space-x-2 flex-grow basis-1/3"> <div id="mistakeTracker" class="flex space-x-1"></div>
                         <div id="languageSelectionInGameContainer" class="hidden">
                             <label for="languageSelectorInGame" class="text-xs sm:text-sm text-slate-700">Speech:</label>
                             <select id="languageSelectorInGame" class="bg-gray-50 border border-gray-300 text-gray-900 text-xs sm:text-sm rounded-md sm:rounded-lg focus:ring-teal-500 focus:border-teal-500 block p-1.5 sm:p-2.5">
                                <option value="en-US">English (US)</option>
                                <option value="en-GB">English (UK)</option>
                                <option value="es-ES">Español (España)</option>
                                <option value="es-MX">Español (México)</option>
                                <option value="fr-FR">Français (France)</option>
                                <option value="de-DE">Deutsch (German)</option>
                                <option value="it-IT">Italiano (Italian)</option>
                                <option value="pt-PT">Português (Portugal)</option>
                                <option value="ja-JP">日本語 (Japanese)</option>
                                <option value="ko-KR">한국어 (Korean)</option>
                                <option value="zh-CN">中文 (简体 Chinese)</option>
                                <option value="nl-NL">Nederlands (Dutch)</option>
                                <option value="ru-RU">Русский (Russian)</option>
                                <option value="ar-SA">العربية (Arabic)</option>
                                <option value="hi-IN">हिन्दी (Hindi)</option>
                                <option value="tl-PH">Tagalog (Filipino)</option>
                             </select>
                        </div>
                    </div>
                    <div class="flex items-center justify-center flex-grow basis-1/3"> <button id="hearItOutLoudToggleBtn" class="btn btn-outline text-xs sm:text-sm py-1 px-1.5 sm:py-1 sm:px-2 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 sm:h-4 sm:w-4 inline-block mr-0.5 sm:mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15z"></path></svg>
                        <span id="hearItOutLoudBtnText">Hear: OFF</span>
                    </button>
                    </div>
                    <div id="scoreDisplayContainer" class="text-right flex-grow basis-1/3"> <div id="currentScoreDisplay" class="text-lg sm:text-xl font-semibold text-teal-600">Score: 0</div>
                        <div id="maxScoreDisplay" class="text-xs sm:text-sm text-teal-500">Max Score: 0</div>
                    </div>
                </div>
                <p id="ttsGeneralStatus" class="text-center text-xs text-red-500 mt-1 h-4"></p>
                <hr class="my-3 sm:my-4 border-teal-200">

                <div id="partSelectionContainer" class="hidden mb-4 sm:mb-6">
                    <h3 class="text-lg sm:text-xl font-semibold text-teal-700 mb-2 sm:mb-3">Choose a Part to Study:</h3>
                    <div id="partButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-2 sm:gap-3"></div>
                </div>

                <div id="flashcardStackSelection" class="hidden mb-4 sm:mb-6">
                    <h3 class="text-lg sm:text-xl font-semibold text-teal-700 mb-2 sm:mb-3">Choose a Flashcard Stack:</h3>
                    <div id="stackButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-2 sm:gap-3"></div>
                </div>

                <div id="flashcardGame" class="hidden">
                    <div id="flashcard" class="game-card card bg-sky-100 border-sky-300 min-h-[150px] sm:min-h-[200px] text-xl sm:text-2xl font-medium text-sky-800 mb-3 sm:mb-4 relative p-3 sm:p-4">
                        <div id="flashcardFront" class="">Tap to flip</div>
                        <div id="flashcardBack" class="hidden absolute inset-0 flex items-center justify-center bg-emerald-100 border-emerald-300 text-emerald-800 p-3 sm:p-4"></div>
                    </div>
                    <div class="flex justify-center space-x-2 sm:space-x-4">
                        <button id="prevCardBtn" class="btn btn-primary">Previous</button>
                        <button id="nextCardBtn" class="btn btn-primary">Next</button>
                    </div>
                    <p id="flashcardCounter" class="text-center text-xs sm:text-sm text-slate-500 mt-3 sm:mt-4"></p>
                </div>

                <div id="matchingGame" class="hidden">
                    <p id="matchingInstructions" class="text-slate-600 mb-3 sm:mb-4 text-sm sm:text-base">Match Target Language to Your Language.</p>
                    <div id="matchingGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 sm:gap-3 md:gap-4"></div>
                    <p id="matchingFeedback" class="text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-sm sm:text-base"></p>
                    <div class="text-center mt-3 sm:mt-4">
                         <button id="resetCurrentPartBtn" class="btn btn-primary">Restart This Part</button>
                    </div>
                </div>

                 <div id="findTheWordsGame" class="hidden">
                    <p id="findTheWordsInstructions" class="text-slate-600 mb-2 text-sm sm:text-base">Listen carefully and select the words you hear (in the Target Language).</p>
                    <div class="flex flex-col sm:flex-row justify-between items-center mb-3 sm:mb-4 gap-2">
                        <button id="replayFindTheWordsAudioBtn" class="btn btn-secondary text-xs sm:text-sm py-1.5 px-2 sm:py-2 sm:px-3 w-full sm:w-auto">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15z"></path></svg>
                            Replay Audio
                        </button>
                        <span id="findTheWordsRoundCounter" class="text-xs sm:text-sm text-slate-500">Round: 1/5</span>
                    </div>
                    <div id="findTheWordsGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 sm:gap-3 mb-3 sm:mb-4"></div>
                    <button id="sendFindTheWordsBtn" class="btn btn-primary w-full sm:w-auto" disabled>Send Answer</button>
                    <p id="findTheWordsFeedback" class="text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-sm sm:text-base"></p>
                    <div class="text-center mt-4 sm:mt-6">
                        <button id="nextFindTheWordsRoundBtn" class="btn btn-primary hidden">Next Round</button>
                    </div>
                </div>

                <div id="multipleChoiceGame" class="hidden">
                    <p id="mcqInstructions" class="text-slate-600 mb-3 sm:mb-4 text-sm sm:text-base">Choose the correct Translation for the Target Language word.</p>
                    <div id="mcqQuestion" class="card non-interactive-card bg-sky-50 p-3 sm:p-4 mb-3 sm:mb-4 text-lg sm:text-xl font-medium text-sky-700 text-center min-h-[70px] sm:min-h-[80px] flex items-center justify-center"></div>
                    <div id="mcqOptions" class="space-y-2 sm:space-y-3"></div>
                    <p id="mcqFeedback" class="text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-sm sm:text-base"></p>
                    <div class="text-center mt-4 sm:mt-6">
                        <button id="nextMcqBtn" class="btn btn-primary hidden">Next Question</button>
                    </div>
                </div>

                <div id="typeTranslationGame" class="hidden">
                    <p id="typeTranslationInstructions" class="text-slate-600 mb-3 sm:mb-4 text-sm sm:text-base">Type the Target Language translation for the word/phrase shown in Your Language.</p>
                    <div id="typeTranslationPhrase" class="card non-interactive-card bg-sky-50 p-3 sm:p-4 mb-3 sm:mb-4 text-lg sm:text-xl font-medium text-sky-700 text-center min-h-[70px] sm:min-h-[80px] flex items-center justify-center"></div>
                    <input type="text" id="typeTranslationInput" class="w-full p-2.5 sm:p-3 border border-slate-300 rounded-lg focus:ring-teal-500 focus:border-teal-500 mb-2 text-sm sm:text-base" placeholder="Type Target Language translation here...">
                    <div class="flex flex-col sm:flex-row justify-between items-center mb-3 sm:mb-4 gap-2">
                        <button id="hintTypeTranslationBtn" class="btn btn-warning text-xs sm:text-sm py-1.5 px-2 sm:py-2 sm:px-3 w-full sm:w-auto">Hint</button>
                        <p id="typeTranslationHintDisplay" class="text-xs sm:text-sm text-amber-700 h-5 flex-grow text-right pr-0 sm:pr-2"></p>
                    </div>
                    <button id="checkTypeTranslationBtn" class="btn btn-primary w-full sm:w-auto">Check Answer</button>
                    <p id="typeTranslationFeedback" class="text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-sm sm:text-base"></p>
                    <div class="text-center mt-4 sm:mt-6">
                        <button id="nextTypeTranslationBtn" class="btn btn-primary hidden">Next Phrase</button>
                    </div>
                     <p id="typeTranslationCounter" class="text-center text-xs sm:text-sm text-slate-500 mt-3 sm:mt-4"></p>
                </div>

                <div id="fillInTheBlanksGame" class="hidden">
                    <p id="fillInTheBlanksInstructions" class="text-slate-600 mb-3 sm:mb-4 text-sm sm:text-base">Fill in the blank with the correct English word (Essentials Mode Only).</p>
                    <div id="fillInTheBlanksSentence" class="card non-interactive-card bg-sky-50 p-4 sm:p-6 mb-3 sm:mb-4 text-lg sm:text-xl font-medium text-sky-700 text-center min-h-[80px] sm:min-h-[100px] flex items-center justify-center leading-relaxed"></div>
                    <input type="text" id="fillInTheBlanksInput" class="w-full p-2.5 sm:p-3 border border-slate-300 rounded-lg focus:ring-teal-500 focus:border-teal-500 mb-3 sm:mb-4 text-sm sm:text-base" placeholder="Type the missing word...">
                    <button id="checkFillInTheBlanksBtn" class="btn btn-primary w-full sm:w-auto">Check Answer</button>
                    <p id="fillInTheBlanksFeedback" class="text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-sm sm:text-base"></p>
                    <div class="text-center mt-4 sm:mt-6">
                        <button id="nextFillInTheBlanksBtn" class="btn btn-primary hidden">Next Question</button>
                    </div>
                    <p id="fillInTheBlanksCounter" class="text-center text-xs sm:text-sm text-slate-500 mt-3 sm:mt-4"></p>
                </div>

                <div id="talkToMeGame" class="hidden">
                    <p id="talkToMeInstructions" class="text-slate-600 mb-2 text-sm sm:text-base">Read the Target Language phrase aloud.</p>
                    <div id="talkToMePhraseToRead" class="card non-interactive-card bg-sky-100 border-sky-300 p-4 sm:p-6 mb-3 sm:mb-4 text-xl sm:text-2xl font-semibold text-sky-800 text-center relative">
                        <span id="talkToMePhraseText"></span>
                        <button id="speakPhraseBtn" class="btn btn-outline p-1 absolute bottom-1 sm:bottom-2 left-1/2 transform -translate-x-1/2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293 1.293a1 1 0 01-1.414-1.414L13.586 10l-1.293-1.293a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <div class="flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-3 mb-3 sm:mb-4">
                        <button id="listenBtn" class="btn btn-primary w-full sm:w-auto">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 inline-block mr-1 sm:mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H7a1 1 0 100 2h6a1 1 0 100-2h-2v-2.07z" clip-rule="evenodd" /></svg>
                            <span id="listenBtnText">Start Listening</span>
                        </button>
                        <button id="nextTalkToMeBtn" class="btn btn-secondary w-full sm:w-auto hidden">Next Phrase</button>
                    </div>
                    <div class="my-2 sm:my-3 p-2 sm:p-3 bg-slate-50 rounded-lg border border-slate-200">
                        <p class="text-xs sm:text-sm text-slate-500 mb-1">What I heard:</p>
                        <p id="talkToMeRecognizedText" class="text-slate-700 font-medium italic text-sm sm:text-base">...</p>
                    </div>
                    <p id="talkToMeFeedback" class="text-center font-medium mt-2 sm:mt-3 h-5 sm:h-6 text-sm sm:text-base"></p>
                    <div id="talkToMeReferenceContainer" class="mt-2 sm:mt-3 p-2 sm:p-3 bg-emerald-50 rounded-lg border border-emerald-200 hidden">
                         <p id="talkToMeReferenceLabel" class="text-xs sm:text-sm text-emerald-600 mb-1">Your Language Translation:</p>
                         <p id="talkToMeReferenceDisplay" class="text-emerald-700 font-medium text-sm sm:text-base"></p>
                    </div>
                    <p id="talkToMeCounter" class="text-center text-xs sm:text-sm text-slate-500 mt-3 sm:mt-4"></p>
                    <p id="speechApiStatus" class="text-center text-xs text-red-500 mt-1 sm:mt-2 h-4"></p>
                </div>

                <div id="roundCompleteMessage" class="hidden"></div>
                <div id="bonusRoundCountdownMessage" class="hidden"></div>
                <p id="gameOverMessage" class="text-center text-xl sm:text-2xl font-bold text-red-600 my-4 sm:my-6 hidden"></p>
                <p id="noVocabularyMessage" class="text-center text-red-500 hidden">Please upload a vocabulary list first.</p>
            </section>
        </div>
    </div>

    <script>
        const { createClient } = supabase; 
        const SUPABASE_URL = 'https://yxngigimphtfoslzmksn.supabase.co';
        // IMPORTANT: Replace this with your actual Supabase anon key
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4bmdpZ2ltcGh0Zm9zbHpta3NuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwMjk2NDUsImV4cCI6MjA2ODYwNTY0NX0.c4b45vxCOnmLV6VY7w0DsPr2cAzRf9zNbqaXkKaWmYQ'; 

        // CORRECTED: Create a new client instance. This was the main error.
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);


        // --- Authentication Logic ---
        const googleLoginBtn = document.getElementById('googleLoginBtn');
        const authForm = document.getElementById('authForm');
const authTitle = document.getElementById('authTitle');
const authSubmitBtn = document.getElementById('authSubmitBtn');
const authToggleText = document.getElementById('authToggleText');
const toggleToSignUp = document.getElementById('toggleToSignUp');
const authError = document.getElementById('authError');

   
        if (googleLoginBtn) {
            googleLoginBtn.addEventListener('click', async () => {
                const { error } = await supabaseClient.auth.signInWithOAuth({
                    provider: 'google',
                });
                if (error) {
                    console.error('Error logging in with Google:', error.message);
                    alert('Error logging in: ' + error.message);
                }
            });
        }

        if (toggleToSignUp) {
    toggleToSignUp.addEventListener('click', (e) => {
        e.preventDefault();
        isSignUp = !isSignUp; // Flip the mode

        authTitle.textContent = isSignUp ? 'Create a New Account' : 'Login to Your Account';
        authSubmitBtn.textContent = isSignUp ? 'Sign Up' : 'Login';
        authToggleText.innerHTML = isSignUp 
            ? `Already have an account? <span id="toggleToLogin" class="toggle-auth-link">Login</span>` 
            : `Don't have an account? <span id="toggleToSignUp" class="toggle-auth-link">Sign Up</span>`;

        // This makes the new "Login" link work after you switch to Sign Up
        const newToggleLink = document.getElementById('toggleToLogin') || document.getElementById('toggleToSignUp');
        if (newToggleLink) {
            newToggleLink.addEventListener('click', (e) => {
                e.preventDefault();
                // Find the original toggle element (which is now hidden but we can still access its click handler)
                const originalToggle = document.querySelector('.toggle-auth-link');
                if(originalToggle) originalToggle.click();
            });
        }
    });
}
     if (authForm) {
    authForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('emailInput').value;
        const password = document.getElementById('passwordInput').value;
        authError.textContent = ''; // Clear previous errors

        if (isSignUp) {
            // --- Sign Up Logic ---
            const { data, error } = await supabaseClient.auth.signUp({
                email: email,
                password: password,
            });
            if (error) {
                authError.textContent = error.message;
            } else if (data.user) {
                alert('Sign up successful! Please check your email to confirm your account.');
                // Switch back to login mode
                const toggleLink = document.querySelector('.toggle-auth-link');
                if(toggleLink) toggleLink.click();
            }
        } else {
            // --- Login Logic ---
            const { error } = await supabaseClient.auth.signInWithPassword({
                email: email,
                password: password,
            });
            if (error) {
                authError.textContent = error.message;
            }
            // Successful login will be handled by the onAuthStateChange listener which we will add next.
        }
    });
}

// --- Listen for authentication state changes to show/hide content ---
const loginSection = document.getElementById('loginSection');
const appContent = document.getElementById('appContent');
const logoutBtn = document.getElementById('logoutBtn');

supabaseClient.auth.onAuthStateChange((event, session) => {
    if (session) {
        // User is logged in
        loginSection.classList.add('hidden');
        appContent.classList.remove('hidden');
    } else {
        // User is logged out
        loginSection.classList.remove('hidden');
        appContent.classList.add('hidden');
    }
});

// --- Logout Button Logic ---
if(logoutBtn) {
    logoutBtn.addEventListener('click', async () => {
        await supabaseClient.auth.signOut();
    });
}
        
        // --- FULL ORIGINAL GAME LOGIC RESTORED BELOW ---
        // --- FULL ORIGINAL GAME LOGIC RESTORED BELOW ---
        // --- Global Constants ---
        const MAX_MISTAKES = 3;
        const FAST_ANSWER_THRESHOLD = 5000; 
        const POINTS_CORRECT_TALK_TO_ME = 5;
        const POINTS_FAST_CORRECT = 10;
        const POINTS_SLOW_CORRECT = 5;
        const POINTS_INCORRECT = -10;
        const ITEMS_PER_PART = 32; 
        const ITEMS_PER_SUB_ROUND = 8; 
        const MAX_GAME_ITEMS_FILL_BLANKS = 10;
        const TEXT_TRUNCATE_LENGTH = 60;
        const MAX_FIND_WORDS_ROUNDS = 5;
        const WORDS_PER_FIND_WORDS_DISPLAY = 8;
        const WORDS_PER_FIND_WORDS_TARGET = 3;
        const FIND_WORDS_REQUIRED_VOCAB = 15; 
        const LEARNED_THRESHOLD_GAMES = 4; 
        const MASTERED_THRESHOLD_SPEAK_LISTEN = 5; 

        // --- Global State ---
        let vocabulary = []; 

        let csvUploadedTargetLanguage = 'en-US'; 
        let activeTargetStudyLanguage = 'en-US'; 
        let selectedSpeechLangInGame = 'en-US'; 
        let activeGameType = null;

        let gameScores = { flashcards: 0, matching: 0, multipleChoice: 0, typeTranslation: 0, talkToMe: 0, fillInTheBlanks: 0, findTheWords: 0 };
        let sessionScores = { ...gameScores }; 

        let currentFlashcardStack = [];
        let currentFlashcardIndex = 0;
        let currentFlashcardSide = 'front';
        
        let currentGameActiveList = []; 
        let currentGameSubRoundOffset = 0; 

        let mcqGameActiveVocab = []; 
        let currentMcqIndex = 0; 

        let matchingGameActiveVocab = []; 
        let selectedMatchCard = null; 
        let matchedPairs = 0; 
        let pairsToMatch = 0; 

        let typeTransGameActiveVocab = [];
        let currentTypeTranslationIndex = 0;
        
        let talkToMeActiveVocab = [];
        let currentTalkToMeIndex = 0;
        
        let currentFillBlanksIndex = 0;
        let mistakesRemaining = MAX_MISTAKES;
        let currentScore = 0; 
        let sessionMaxScore = 0; 
        let mistakeItems = []; 
        let correctlyAnsweredItemsInPart = new Set(); 
        let currentVocabularyPart = []; 
        let currentPartName = ""; 
        let currentPartIndexGlobal = -1; 
        let currentPartIndexGlobalForBonusReturn = -1; 
        let questionStartTime = 0;
        let hintUsedForCurrentTypeTranslation = false;
        let isBonusRound = false;
        let attemptCountForCurrentTalkToMeItem = 0;
        let isEssentialsMode = false;
        let currentEssentialsCategoryName = "";
        
        let findWordsSessionPool = [];
        let currentFindWordsRound = 0;
        let findWordsCurrentChoices = []; 
        let findWordsTargetWords = []; 
        let findWordsSelectedWords = []; 
        
        let backgroundMusicSynth, correctMatchSynth, incorrectBuzzSynth, notebookLostSynth;
        let musicPlaying = false;
        let audioInitialized = false;
        let hearItOutLoudEnabled = false;
        let recognition;
        let isListening = false;

        // --- DOM Elements ---
        const mainSelectionSection = document.getElementById('mainSelectionSection');
        const showUploadSectionBtn = document.getElementById('showUploadSectionBtn');
        const showEssentialsSectionBtn = document.getElementById('showEssentialsSectionBtn');
        const csvFileInput = document.getElementById('csvFile');
        const targetLanguageSelector = document.getElementById('targetLanguageSelector');
        const languageSelectorInGame = document.getElementById('languageSelectorInGame');
        const languageSelectionInGameContainer = document.getElementById('languageSelectionInGameContainer');
        const uploadBtn = document.getElementById('uploadBtn');
        const uploadStatus = document.getElementById('uploadStatus');
        const uploadSection = document.getElementById('uploadSection');
        const dropZone = document.getElementById('dropZone');
        const backToMainSelectionFromUploadBtn = document.getElementById('backToMainSelectionFromUploadBtn');
        const essentialsCategorySelectionSection = document.getElementById('essentialsCategorySelectionSection');
        const essentialsCategoryButtonsContainer = document.getElementById('essentialsCategoryButtonsContainer');
        const backToMainSelectionFromEssentialsBtn = document.getElementById('backToMainSelectionFromEssentialsBtn');
        const essentialsCategoryOptionsSection = document.getElementById('essentialsCategoryOptionsSection');
        const essentialsOptionsTitle = document.getElementById('essentialsOptionsTitle');
        const reviewEssentialsCategoryBtn = document.getElementById('reviewEssentialsCategoryBtn');
        const playGamesWithEssentialsBtn = document.getElementById('playGamesWithEssentialsBtn');
        const backToEssentialsCategoriesBtn = document.getElementById('backToEssentialsCategoriesBtn');
        const gameSelectionSection = document.getElementById('gameSelectionSection');
        const gameButtonsContainer = document.getElementById('gameButtonsContainer');
        const backToSourceSelectionBtn = document.getElementById('backToSourceSelectionBtn');
        const gameArea = document.getElementById('gameArea');
        const noVocabularyMessage = document.getElementById('noVocabularyMessage');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const roundCompleteMessageDiv = document.getElementById('roundCompleteMessage');
        const bonusRoundCountdownMessageDiv = document.getElementById('bonusRoundCountdownMessage');
        const flashcardsBtn = document.getElementById('flashcardsBtn');
        const matchingBtn = document.getElementById('matchingBtn');
        const multipleChoiceBtn = document.getElementById('multipleChoiceBtn');
        const typeTranslationBtn = document.getElementById('typeTranslationBtn');
        const talkToMeBtn = document.getElementById('talkToMeBtn');
        const fillInTheBlanksBtn = document.getElementById('fillInTheBlanksBtn');
        const findTheWordsBtn = document.getElementById('findTheWordsBtn');
        const backToGameSelectionBtn = document.getElementById('backToGameSelectionBtn');
        const gameTitle = document.getElementById('gameTitle');
        const musicToggleBtn = document.getElementById('musicToggleBtn');
        const musicIconOn = document.getElementById('musicIconOn');
        const musicIconOff = document.getElementById('musicIconOff');
        const musicStatusText = document.getElementById('musicStatusText');
        const mistakeTrackerDiv = document.getElementById('mistakeTracker');
        const currentScoreDisplay = document.getElementById('currentScoreDisplay');
        const maxScoreDisplay = document.getElementById('maxScoreDisplay');
        const partSelectionContainer = document.getElementById('partSelectionContainer');
        const partButtonsContainer = document.getElementById('partButtonsContainer');
        const flashcardStackSelectionContainer = document.getElementById('flashcardStackSelection');
        const stackButtonsContainer = document.getElementById('stackButtonsContainer');
        const flashcardGameContainer = document.getElementById('flashcardGame');
        const flashcardDiv = document.getElementById('flashcard');
        const flashcardFront = document.getElementById('flashcardFront');
        const flashcardBack = document.getElementById('flashcardBack');
        const prevCardBtn = document.getElementById('prevCardBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const flashcardCounter = document.getElementById('flashcardCounter');
        const matchingGameContainer = document.getElementById('matchingGame');
        const matchingGrid = document.getElementById('matchingGrid');
        const matchingInstructions = document.getElementById('matchingInstructions');
        const matchingFeedback = document.getElementById('matchingFeedback');
        const resetCurrentPartBtn = document.getElementById('resetCurrentPartBtn');
        const multipleChoiceGameContainer = document.getElementById('multipleChoiceGame');
        const mcqInstructions = document.getElementById('mcqInstructions');
        const mcqQuestion = document.getElementById('mcqQuestion');
        const mcqOptions = document.getElementById('mcqOptions');
        const mcqFeedback = document.getElementById('mcqFeedback');
        const nextMcqBtn = document.getElementById('nextMcqBtn');
        let mcqAnswered = false; 
        const typeTranslationGameContainer = document.getElementById('typeTranslationGame');
        const typeTranslationInstructions = document.getElementById('typeTranslationInstructions');
        const typeTranslationPhrase = document.getElementById('typeTranslationPhrase');
        const typeTranslationInput = document.getElementById('typeTranslationInput');
        const hintTypeTranslationBtn = document.getElementById('hintTypeTranslationBtn');
        const typeTranslationHintDisplay = document.getElementById('typeTranslationHintDisplay');
        const checkTypeTranslationBtn = document.getElementById('checkTypeTranslationBtn');
        const typeTranslationFeedback = document.getElementById('typeTranslationFeedback');
        const nextTypeTranslationBtn = document.getElementById('nextTypeTranslationBtn');
        const typeTranslationCounter = document.getElementById('typeTranslationCounter');
        let typeTranslationAnswered = false; 
        const fillInTheBlanksGameContainer = document.getElementById('fillInTheBlanksGame');
        const fillInTheBlanksInstructions = document.getElementById('fillInTheBlanksInstructions');
        const fillInTheBlanksSentence = document.getElementById('fillInTheBlanksSentence');
        const fillInTheBlanksInput = document.getElementById('fillInTheBlanksInput');
        const checkFillInTheBlanksBtn = document.getElementById('checkFillInTheBlanksBtn');
        const fillInTheBlanksFeedback = document.getElementById('fillInTheBlanksFeedback');
        const nextFillInTheBlanksBtn = document.getElementById('nextFillInTheBlanksBtn');
        const fillInTheBlanksCounter = document.getElementById('fillInTheBlanksCounter');
        let fillBlanksAnswered = false; 
        let fillBlanksGameActiveVocab = []; 
        const findTheWordsGameContainer = document.getElementById('findTheWordsGame');
        const findTheWordsInstructions = document.getElementById('findTheWordsInstructions');
        const replayFindTheWordsAudioBtn = document.getElementById('replayFindTheWordsAudioBtn');
        const findTheWordsRoundCounter = document.getElementById('findTheWordsRoundCounter');
        const findTheWordsGrid = document.getElementById('findTheWordsGrid');
        const sendFindTheWordsBtn = document.getElementById('sendFindTheWordsBtn');
        const findTheWordsFeedback = document.getElementById('findTheWordsFeedback');
        const nextFindTheWordsRoundBtn = document.getElementById('nextFindTheWordsRoundBtn');
        const talkToMeGameContainer = document.getElementById('talkToMeGame');
        const talkToMeInstructions = document.getElementById('talkToMeInstructions');
        const talkToMePhraseToRead = document.getElementById('talkToMePhraseToRead');
        const talkToMePhraseText = document.getElementById('talkToMePhraseText');
        const speakPhraseBtn = document.getElementById('speakPhraseBtn');
        const listenBtn = document.getElementById('listenBtn');
        const listenBtnText = document.getElementById('listenBtnText');
        const nextTalkToMeBtn = document.getElementById('nextTalkToMeBtn');
        const talkToMeRecognizedText = document.getElementById('talkToMeRecognizedText');
        const talkToMeFeedback = document.getElementById('talkToMeFeedback');
        const talkToMeReferenceContainer = document.getElementById('talkToMeReferenceContainer');
        const talkToMeReferenceLabel = document.getElementById('talkToMeReferenceLabel');
        const talkToMeReferenceDisplay = document.getElementById('talkToMeReferenceDisplay');
        const talkToMeCounter = document.getElementById('talkToMeCounter');
        const speechApiStatus = document.getElementById('speechApiStatus');
        const hearItOutLoudToggleBtn = document.getElementById('hearItOutLoudToggleBtn');
        const hearItOutLoudBtnText = document.getElementById('hearItOutLoudBtnText');
        const ttsGeneralStatus = document.getElementById('ttsGeneralStatus');

        const essentialsVocabularyData = {
            "Travel (EN-ES)": [
                { lang1: "passport", lang2: "pasaporte", sentence: "You need a ____ to travel abroad.", correctCount: 0, originalIndex: 0 },
                { lang1: "ticket", lang2: "billete", sentence: "I bought a round-trip ____ to Paris.", correctCount: 0, originalIndex: 1 },
                { lang1: "luggage", lang2: "equipaje", sentence: "My ____ was too heavy.", correctCount: 0, originalIndex: 2 },
                { lang1: "destination", lang2: "destino", sentence: "Our final ____ is Rome.", correctCount: 0, originalIndex: 3 },
                { lang1: "reservation", lang2: "reserva", sentence: "I made a hotel ____ online.", correctCount: 0, originalIndex: 4 }
            ],
            "Business (EN-ES)": [
                { lang1: "meeting", lang2: "reunión", sentence: "The client ____ is at 2 PM.", correctCount: 0, originalIndex: 0 },
                { lang1: "contract", lang2: "contrato", sentence: "Please review the ____ carefully.", correctCount: 0, originalIndex: 1 },
                { lang1: "negotiation", lang2: "negociación", sentence: "The ____ lasted for hours.", correctCount: 0, originalIndex: 2 },
                { lang1: "deadline", lang2: "fecha límite", sentence: "We must meet the project ____.", correctCount: 0, originalIndex: 3 },
                { lang1: "presentation", lang2: "presentación", sentence: "She gave an excellent ____.", correctCount: 0, originalIndex: 4 }
            ],
            "Food (EN-FR)": [
                { lang1: "bread", lang2: "pain", sentence: "I would like some ____, please.", correctCount: 0, originalIndex: 0 },
                { lang1: "water", lang2: "eau", sentence: "Can I have a glass of ____?", correctCount: 0, originalIndex: 1 }
            ]
        };
        Object.values(essentialsVocabularyData).forEach(categoryArray => {
            categoryArray.forEach((item, index) => {
                if (item.originalIndex === undefined) item.originalIndex = index;
                if (item.correctCount === undefined) item.correctCount = 0;
            });
        });
// --- Utility Functions ---
        function truncateText(text, maxLength = TEXT_TRUNCATE_LENGTH) {
            if (typeof text !== 'string') text = String(text); 
            return text.length > maxLength ? text.substring(0, maxLength) + "..." : text;
        }

        function shuffleArray(array) {
            const newArray = [...array]; 
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; 
            }
            return newArray;
        }

        function getEffectiveLanguages(item, isEssentialsModeActive, currentActiveSpokenLang) {
            if (!item) return { target: "", translation: "" };
            if (isEssentialsModeActive) {
                if (currentActiveSpokenLang && !currentActiveSpokenLang.toLowerCase().startsWith('en') && item.lang2) {
                    return { target: item.lang2, translation: item.lang1 };
                } else {
                    return { target: item.lang1, translation: item.lang2 };
                }
            } else {
                return { target: item.lang1, translation: item.lang2 };
            }
        }

        function categorizeTerm(term, lang) {
            let mainCategory = 'word';
            let subCategory = null;
            const words = term.trim().split(/\s+/).filter(Boolean);
            const wordCount = words.length;

            if (wordCount > 1) {
                mainCategory = 'phrase';
            }

            const singleWord = words[0]?.toLowerCase();

            if (wordCount === 1 && singleWord) {
                if (!isNaN(parseFloat(singleWord)) && isFinite(singleWord)) {
                    subCategory = 'number';
                } else {
                    if (lang.startsWith('en')) { 
                        if (singleWord.match(/^(is|am|are|was|were|be|have|has|had|do|does|did|will|can|could|may|might|should|would|go|get|say|see|make|know|take|come|think|look|want|give|use|find|tell|ask|work|seem|feel|try|leave|call)$/i)) subCategory = 'verb';
                        else if (singleWord.endsWith('ing') || singleWord.endsWith('ed') || singleWord.endsWith('ize') || singleWord.endsWith('ate') || singleWord.endsWith('ify') || singleWord.endsWith('en')) subCategory = 'verb';
                        else if (singleWord.endsWith('tion') || singleWord.endsWith('sion') || singleWord.endsWith('ment') || singleWord.endsWith('ness') || singleWord.endsWith('ity') || singleWord.endsWith('er') || singleWord.endsWith('or') || singleWord.endsWith('ist') || singleWord.endsWith('ism') || singleWord.endsWith('age')) subCategory = 'noun';
                    } else if (lang.startsWith('fr')) { 
                        if (singleWord.match(/^(être|avoir|faire|aller|pouvoir|vouloir|devoir|dire|voir|savoir|venir|falloir|croire|trouver|donner|parler|aimer|passer|mettre|demander|tenir|sembler|laisser|rester)$/i)) subCategory = 'verb';
                        else if (singleWord.endsWith('er') || singleWord.endsWith('ir') || singleWord.endsWith('re') || singleWord.endsWith('oir')) subCategory = 'verb';
                        else if (singleWord.endsWith('tion') || singleWord.endsWith('age') || singleWord.endsWith('ment') || singleWord.endsWith('isme') || singleWord.endsWith('eur') || singleWord.endsWith('euse') || singleWord.endsWith('té') || singleWord.endsWith('esse')) subCategory = 'noun';
                    } else if (lang.startsWith('tl')) { 
                        if (singleWord.match(/^(um|mag|ma|mang|maki|nag|na|ini|ina|ika|ipa|ipang|ikapag)/i) || (singleWord.match(/(in|an)$/i) && !singleWord.match(/^(ka|pag|san|pan)/i)) ) subCategory = 'verb';
                        else if (singleWord.match(/^(pag|ka|tag|pala|sinta|taga|pang|pam|pan|sangka)/i) || (singleWord.endsWith('an') && singleWord.match(/^(ka|pag)/i))) subCategory = 'noun';
                    }
                }
            }
            return { mainCategory, subCategory };
        }


        // --- Audio and Speech ---
        function speakText(text, intendedLangOfText) {
            return new Promise((resolve, reject) => {
                const langToUse = selectedSpeechLangInGame || intendedLangOfText;
                if (!text || !langToUse) {
                    console.warn("speakText: No text or language provided.", {text, langToUse});
                    resolve(); return;
                }
                if ('speechSynthesis' in window) {
                    if (ttsGeneralStatus) ttsGeneralStatus.textContent = '';
                    window.speechSynthesis.cancel(); 
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = langToUse;
                    utterance.onend = resolve;
                    utterance.onerror = (e) => {
                        console.error("SpeechSynthesisUtterance error:", e, "Text:", text, "Lang:", langToUse);
                        if (ttsGeneralStatus) ttsGeneralStatus.textContent = `TTS error: ${e.error} for lang ${langToUse}. Try another voice/lang.`;
                        reject(e);
                    };
                    window.speechSynthesis.speak(utterance);
                } else {
                    if (ttsGeneralStatus) ttsGeneralStatus.textContent = "Text-to-Speech not supported by your browser.";
                    console.warn("Speech synthesis not supported.");
                    resolve(); 
                }
            });
        }

        function toggleHearItOutLoud() { hearItOutLoudEnabled = !hearItOutLoudEnabled; updateHearItOutLoudButton(); if (mcqQuestion) mcqQuestion.classList.toggle('speakable-question', hearItOutLoudEnabled && !multipleChoiceGameContainer.classList.contains('hidden')); }
        function updateHearItOutLoudButton() { if (hearItOutLoudToggleBtn && hearItOutLoudBtnText) { hearItOutLoudBtnText.textContent = `Hear: ${hearItOutLoudEnabled ? 'ON' : 'OFF'}`; hearItOutLoudToggleBtn.classList.toggle('active', hearItOutLoudEnabled); } }
        function initializeAudio() { if (audioInitialized) return; Tone.start().then(() => { audioInitialized = true; backgroundMusicSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.2, release: 1 }, volume: -28 }).toDestination(); const vivaldiSpringMotif = [ { time: "0:0", note: "E4", duration: "4n" }, { time: "0:1", note: "E4", duration: "4n" }, { time: "0:2", note: "E4", duration: "4n" }, { time: "0:3", note: "C#5", duration: "4n" }, { time: "1:0", note: "D#5", duration: "4n" }, { time: "1:1", note: "D#5", duration: "4n" }, { time: "1:2", note: "D#5", duration: "4n" }, { time: "1:3", note: "B4", duration: "4n" }, { time: "2:0", note: "E4", duration: "4n" }, { time: "2:1", note: "E4", duration: "4n" }, { time: "2:2", note: "E4", duration: "4n" }, { time: "2:3", note: "C#5", duration: "4n" }, { time: "3:0", note: "D#5", duration: "4n" }, { time: "3:1", note: "D#5", duration: "4n" }, { time: "3:2", note: "B4", duration: "4n" }, { time: "3:3", note: "E4", duration: "4n" } ]; const musicPart = new Tone.Part((time, value) => backgroundMusicSynth.triggerAttackRelease(value.note, value.duration, time), vivaldiSpringMotif).start(0); musicPart.loop = true; musicPart.loopEnd = "4m"; correctMatchSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -12 }).toDestination(); incorrectBuzzSynth = new Tone.NoiseSynth ({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 }, volume: -18 }).toDestination(); notebookLostSynth = new Tone.MonoSynth({ oscillator: { type: "sawtooth" }, filter: { Q: 2, type: "lowpass", rolloff: -24 }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.3 }, filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.2, baseFrequency: 200, octaves: 2 }, volume: -15 }).toDestination(); updateMusicButton(); if(musicPlaying && Tone.Transport.state !== "started") Tone.Transport.start(); else if (!musicPlaying && Tone.Transport.state === "started") Tone.Transport.pause(); }).catch(e => console.error("Failed to start audio context:", e)); }
        function toggleMusic() { if (!audioInitialized) { initializeAudio(); musicPlaying = !musicPlaying; return; } musicPlaying = !musicPlaying; if (musicPlaying && Tone.Transport.state !== "started") Tone.Transport.start(); else if (!musicPlaying && Tone.Transport.state === "started") Tone.Transport.pause(); updateMusicButton(); }
        function updateMusicButton() { if (musicPlaying) { musicIconOn.classList.remove('hidden'); musicIconOff.classList.add('hidden'); musicStatusText.textContent = "Music: ON"; } else { musicIconOn.classList.add('hidden'); musicIconOff.classList.remove('hidden'); musicStatusText.textContent = "Music: OFF"; } }
        function playCorrectMatchSound() { if (audioInitialized && correctMatchSynth) { correctMatchSynth.triggerAttackRelease("C5", "8n", Tone.now()); correctMatchSynth.triggerAttackRelease("G5", "4n", Tone.now() + 0.12); } }
        function playIncorrectSound() {  if (audioInitialized && incorrectBuzzSynth) { incorrectBuzzSynth.triggerAttackRelease("0.2n"); } }
        function playNotebookLostSound() { if (audioInitialized && notebookLostSynth) { notebookLostSynth.triggerAttackRelease("C3", "0.3n"); } }

        // --- Game State & Scoring ---
        function setupMistakeTracker() { mistakeTrackerDiv.innerHTML = ''; for (let i = 0; i < MAX_MISTAKES; i++) { const capybaraSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg"); capybaraSvg.setAttribute("viewBox", "0 0 60 60"); capybaraSvg.setAttribute("fill", "currentColor"); capybaraSvg.classList.add("capybara-life-icon"); capybaraSvg.innerHTML = ` <path d="M30,15 C18,15 10,23 10,33 C10,43 15,50 22,52 C20,48 20,42 23,40 C25,38 28,38 30,39 C32,38 35,38 37,40 C40,42 40,48 38,52 C45,50 50,43 50,33 C50,23 42,15 30,15 Z M22,28 A2,2 0 0,1 24,30 A2,2 0 0,1 22,32 A2,2 0 0,1 20,30 A2,2 0 0,1 22,28 Z M38,28 A2,2 0 0,1 40,30 A2,2 0 0,1 38,32 A2,2 0 0,1 36,30 A2,2 0 0,1 38,28 Z M30,42 C28,42 27,41 27,40 C27,39 28,38 30,38 C32,38 33,39 33,40 C33,41 32,42 30,42 Z"></path> <ellipse cx="23" cy="25" rx="3" ry="2" fill="#4a2c2a"/> <ellipse cx="37" cy="25" rx="3" ry="2" fill="#4a2c2a"/> <path d="M28,33 Q30,35 32,33" stroke="#4a2c2a" stroke-width="1.5" fill="none" /> `; mistakeTrackerDiv.appendChild(capybaraSvg); } }
        function updateMistakeDisplay() { const icons = mistakeTrackerDiv.querySelectorAll('.capybara-life-icon'); icons.forEach((icon, index) => { icon.classList.toggle('mistake', index < MAX_MISTAKES - mistakesRemaining); }); }
        function updateScoreDisplay() { currentScoreDisplay.textContent = `Score: ${currentScore}`; maxScoreDisplay.textContent = `Max Score: ${sessionMaxScore}`; }
        function recordMistake(item = null) { if (item && !isBonusRound && !isEssentialsMode) { if (!mistakeItems.find(mi => mi.originalIndex === item.originalIndex && mi.lang1 === item.lang1)) { mistakeItems.push(item); } } if (mistakesRemaining > 0) { mistakesRemaining--; playNotebookLostSound(); updateMistakeDisplay(); if (mistakesRemaining === 0 && !isBonusRound) { let restartFn = showGameSelection; if(!matchingGameContainer.classList.contains('hidden')) restartFn = () => initMatchingGame(false); else if(!multipleChoiceGameContainer.classList.contains('hidden')) restartFn = () => initMultipleChoiceGame(false); else if(!typeTranslationGameContainer.classList.contains('hidden')) restartFn = () => initTypeTranslationGame(false); else if(!talkToMeGameContainer.classList.contains('hidden')) restartFn = () => initTalkToMeGame(false); else if(!fillInTheBlanksGameContainer.classList.contains('hidden')) restartFn = () => initFillInTheBlanksGame(false); else if(!findTheWordsGameContainer.classList.contains('hidden')) restartFn = () => initFindTheWordsGame(); handleGameOver(restartFn); return true; } } return false; }

        function handleCorrectAnswer(isFast, item = null, points = null) {
            const pointsEarned = points !== null ? points : (isFast ? POINTS_FAST_CORRECT : POINTS_SLOW_CORRECT);
            currentScore += pointsEarned;
            if (activeGameType && sessionScores.hasOwnProperty(activeGameType)) {
                sessionScores[activeGameType] += pointsEarned;
            }

            if (currentScore > sessionMaxScore) sessionMaxScore = currentScore;
            updateScoreDisplay();
            playCorrectMatchSound();

            if (item && !isBonusRound) { 
                const mainVocabList = isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName] : vocabulary;
                const vocabItemRef = mainVocabList.find(v =>
                    v.originalIndex === item.originalIndex && v.lang1 === item.lang1 
                );

                if (vocabItemRef) {
                    vocabItemRef.correctCount = (vocabItemRef.correctCount || 0) + 1;
                }
                if (!isEssentialsMode) { 
                     correctlyAnsweredItemsInPart.add(item.originalIndex);
                }
            }
        }
        function handleIncorrectAnswer(item = null, pointsDeducted = POINTS_INCORRECT) { currentScore += pointsDeducted; if (currentScore < 0) currentScore = 0; if (activeGameType && sessionScores.hasOwnProperty(activeGameType)) { sessionScores[activeGameType] += pointsDeducted; if(sessionScores[activeGameType] < 0) sessionScores[activeGameType] = 0;} updateScoreDisplay(); playIncorrectSound(); return recordMistake(item); }
        function handleGameOver(gameSpecificRestartFn) { gameOverMessage.textContent = "Game Over! Too many mistakes. Restarting this part..."; gameOverMessage.classList.remove('hidden'); disableAllGameInteractions(); setTimeout(() => { gameOverMessage.classList.add('hidden'); gameSpecificRestartFn(); }, 2500); }
        function disableAllGameInteractions() { if(nextMcqBtn) nextMcqBtn.classList.add('hidden'); if (mcqOptions) mcqOptions.querySelectorAll('.mcq-option-btn').forEach(btn => btn.disabled = true); if (typeTranslationInput) typeTranslationInput.disabled = true; if (checkTypeTranslationBtn) checkTypeTranslationBtn.disabled = true; if (nextTypeTranslationBtn) nextTypeTranslationBtn.classList.add('hidden'); if (listenBtn) listenBtn.disabled = true; if (nextTalkToMeBtn) nextTalkToMeBtn.classList.add('hidden'); if (checkFillInTheBlanksBtn) checkFillInTheBlanksBtn.disabled = true; if (nextFillInTheBlanksBtn) nextFillInTheBlanksBtn.classList.add('hidden'); if (fillInTheBlanksInput) fillInTheBlanksInput.disabled = true; if (sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = true; if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = true; if (nextFindTheWordsRoundBtn) nextFindTheWordsRoundBtn.classList.add('hidden'); if (findTheWordsGrid) findTheWordsGrid.querySelectorAll('.game-card').forEach(card => card.style.pointerEvents = 'none'); }
        function resetSessionStats() { currentScore = 0; mistakeItems = []; correctlyAnsweredItemsInPart.clear(); isBonusRound = false; resetGameStats(); Object.keys(sessionScores).forEach(key => sessionScores[key] = 0); }
        function resetGameStats() { mistakesRemaining = MAX_MISTAKES; updateScoreDisplay(); setupMistakeTracker(); gameOverMessage.classList.add('hidden'); }
        function startQuestionTimer() { questionStartTime = Date.now(); }
        function getAnswerDuration() { return Date.now() - questionStartTime; }

        // --- Navigation and Setup ---
       // Place this function inside your existing <script> tag in your main HTML file,
// replacing the old handleFileUpload function.

function handleFileUpload(droppedFile = null) {
    const file = droppedFile || (csvFileInput.files.length > 0 ? csvFileInput.files[0] : null);

    if (!file) {
        uploadStatus.textContent = 'Please select or drop a CSV file.';
        uploadStatus.className = 'text-sm text-red-600 mt-2 h-5';
        return;
    }

    if (!(file.type === "text/csv" || file.name.toLowerCase().endsWith(".csv"))) {
        uploadStatus.textContent = 'Invalid file type. Please use a CSV file.';
        uploadStatus.className = 'text-sm text-red-600 mt-2 h-5';
        return;
    }

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            parseCSV(event.target.result);
            if (vocabulary.length > 0) {
                uploadStatus.textContent = `Successfully loaded ${vocabulary.length} pairs!`;
                uploadStatus.className = 'text-sm text-teal-600 mt-2 h-5';
                uploadSection.classList.add('hidden');
                showGameSelection();
            } else {
                uploadStatus.textContent = 'No vocabulary found. Check file format.';
                uploadStatus.className = 'text-sm text-red-600 mt-2 h-5';
            }
        } catch (error) {
            uploadStatus.textContent = 'Error parsing CSV file.';
            uploadStatus.className = 'text-sm text-red-600 mt-2 h-5';
            console.error("Error parsing CSV:", error);
        }
    };
    reader.onerror = () => {
        uploadStatus.textContent = 'Error reading file.';
        uploadStatus.className = 'text-sm text-red-600 mt-2 h-5';
    };
    reader.readAsText(file);
}

        function parseCSV(csvData) {
            vocabulary = [];
            const lines = csvData.split(/\r\n|\n/).slice(1); 

            lines.forEach((line, lineIndex) => {
                if (line.trim() === '') return;

                const parts = [];
                let currentField = '';
                let inQuotedField = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        if (inQuotedField && i + 1 < line.length && line[i + 1] === '"') {
                            currentField += '"';
                            i++; 
                        } else {
                            inQuotedField = !inQuotedField;
                        }
                    } else if (char === ',' && !inQuotedField) {
                        parts.push(currentField);
                        currentField = '';
                    } else {
                        currentField += char;
                    }
                }
                parts.push(currentField); 

                if (parts.length >= 2 && parts[0].trim() && parts[1].trim()) {
                    const lang1Text = parts[0].trim();
                    const lang2Text = parts[1].trim();
                    const sentence = parts.length > 2 && parts[2] ? parts[2].trim() : `This is a ____.`;
                    const { mainCategory, subCategory } = categorizeTerm(lang1Text, csvUploadedTargetLanguage);
                    vocabulary.push({
                        lang1: lang1Text, lang2: lang2Text, originalIndex: vocabulary.length,
                        category: mainCategory, subCategory: subCategory, sentence: sentence, correctCount: 0
                    });
                } else if (line.trim().length > 0) { 
                    console.warn(`Skipping line ${lineIndex + 2} due to insufficient columns or empty required fields: "${line}" Parsed:`, parts);
                }
            });
        }


        function showMainSelection() { mainSelectionSection.classList.remove('hidden'); [uploadSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, gameSelectionSection, gameArea, partSelectionContainer, languageSelectionInGameContainer].forEach(el => el.classList.add('hidden')); isEssentialsMode = false; currentEssentialsCategoryName = ""; sessionMaxScore = 0; updateScoreDisplay(); hearItOutLoudToggleBtn.classList.add('hidden'); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; activeTargetStudyLanguage = csvUploadedTargetLanguage; selectedSpeechLangInGame = csvUploadedTargetLanguage; console.log("Main Selection: Active/InGame Speech lang defaulted to CSV's: " + activeTargetStudyLanguage); }
        function populateEssentialsCategoryButtons() { essentialsCategoryButtonsContainer.innerHTML = ''; Object.keys(essentialsVocabularyData).forEach(categoryKey => { const button = document.createElement('button'); button.className = 'btn essentials-category-btn p-3 sm:p-4 text-sm sm:text-md'; button.textContent = categoryKey; button.addEventListener('click', () => { currentEssentialsCategoryName = categoryKey; isEssentialsMode = true; if (categoryKey.toLowerCase().includes("(en-es)")) { activeTargetStudyLanguage = 'es-ES'; } else if (categoryKey.toLowerCase().includes("(en-fr)")) { activeTargetStudyLanguage = 'fr-FR'; } else { activeTargetStudyLanguage = 'en-US'; } selectedSpeechLangInGame = activeTargetStudyLanguage; console.log(`Essentials Category Clicked: ${categoryKey}. activeTargetStudyLanguage & selectedSpeechLangInGame set to: ${activeTargetStudyLanguage}`); currentVocabularyPart = essentialsVocabularyData[categoryKey].map((item, index) => ({...item, originalIndex: index, correctCount: item.correctCount || 0 })); essentialsOptionsTitle.textContent = `Category: ${categoryKey}`; essentialsCategorySelectionSection.classList.add('hidden'); essentialsCategoryOptionsSection.classList.remove('hidden'); }); essentialsCategoryButtonsContainer.appendChild(button); }); }
        function showGameSelection() {
            if (!isEssentialsMode) {
                activeTargetStudyLanguage = csvUploadedTargetLanguage; 
                selectedSpeechLangInGame = csvUploadedTargetLanguage;
                console.log("Show Game Selection (CSV Mode): Active/InGame Speech lang set to CSV's: " + activeTargetStudyLanguage);
            } else {
                 selectedSpeechLangInGame = activeTargetStudyLanguage; 
                 console.log("Show Game Selection (Essentials Mode): Active/InGame Speech lang is: " + activeTargetStudyLanguage + " for category " + currentEssentialsCategoryName);
            }
            [mainSelectionSection, uploadSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, partSelectionContainer, gameArea, languageSelectionInGameContainer].forEach(el => el.classList.add('hidden'));
            [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden'));
            gameSelectionSection.classList.remove('hidden');
            fillInTheBlanksBtn.classList.toggle('hidden', !isEssentialsMode); 
            findTheWordsBtn.classList.remove('hidden'); 

            const activeVocab = isEssentialsMode ? currentVocabularyPart : vocabulary;
            if (activeVocab.length === 0) { noVocabularyMessage.classList.remove('hidden'); gameButtonsContainer.classList.add('hidden'); }
            else { noVocabularyMessage.classList.add('hidden'); gameButtonsContainer.classList.remove('hidden'); }

            sessionMaxScore = 0; updateScoreDisplay(); 
            hearItOutLoudToggleBtn.classList.add('hidden'); if(ttsGeneralStatus) ttsGeneralStatus.textContent = '';
        }
        function showPartSelection(gameType) {
            if (!isEssentialsMode) { activeTargetStudyLanguage = csvUploadedTargetLanguage; selectedSpeechLangInGame = csvUploadedTargetLanguage; }
            else { selectedSpeechLangInGame = activeTargetStudyLanguage; } 
            if(languageSelectorInGame) languageSelectorInGame.value = selectedSpeechLangInGame; 

            currentPartName = ""; 
            sessionMaxScore = 0; updateScoreDisplay(); 

            const sourceForParts = isEssentialsMode ? currentVocabularyPart : vocabulary;
            if (sourceForParts.length === 0) { noVocabularyMessage.classList.remove('hidden'); gameArea.classList.remove('hidden'); [partSelectionContainer, flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, gameOverMessage, languageSelectionInGameContainer].forEach(el => el.classList.add('hidden')); hearItOutLoudToggleBtn.classList.add('hidden'); return; }

            gameTitle.textContent = gameType.charAt(0).toUpperCase() + gameType.slice(1).replace(/([A-Z])/g, ' $1'); 
            [uploadSection, gameSelectionSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, mainSelectionSection].forEach(el => el.classList.add('hidden'));
            gameArea.classList.remove('hidden');
            partSelectionContainer.classList.remove('hidden');
            languageSelectionInGameContainer.classList.remove('hidden'); 
            [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden'));
            showGameInfoBar(); 
            const showHearButton = gameType === 'flashcards' || gameType === 'matching' || gameType === 'multipleChoice' || gameType === 'findTheWords';
            hearItOutLoudToggleBtn.classList.toggle('hidden', !showHearButton);
            if(showHearButton) updateHearItOutLoudButton();
            if(ttsGeneralStatus) ttsGeneralStatus.textContent = '';

            partButtonsContainer.innerHTML = '';
            const numParts = Math.ceil(sourceForParts.length / ITEMS_PER_PART);

            const fullMixButton = document.createElement('button');
            fullMixButton.className = 'btn part-selection-btn p-3 sm:p-4 text-sm sm:text-md';
            let itemsForFullMixText = isEssentialsMode ? `${sourceForParts.length} items` : `${sourceForParts.length} items`; 
            fullMixButton.textContent = `Full Mix (${itemsForFullMixText})`;
            fullMixButton.addEventListener('click', () => { currentVocabularyPart = [...sourceForParts]; currentPartName = "Full Mix"; currentPartIndexGlobal = -1; startGame(gameType); });
            partButtonsContainer.appendChild(fullMixButton);

            if (!isEssentialsMode && numParts > 1 && sourceForParts.length > ITEMS_PER_PART) {
                for (let i = 0; i < numParts; i++) {
                    const start = i * ITEMS_PER_PART;
                    const end = start + ITEMS_PER_PART;
                    const partVocab = sourceForParts.slice(start, end);
                    if (partVocab.length === 0) continue;
                    const button = document.createElement('button');
                    button.className = 'btn part-selection-btn p-3 sm:p-4 text-sm sm:text-md';
                    button.textContent = `Part ${i + 1} (Items ${start + 1}-${Math.min(end, sourceForParts.length)}) - ${partVocab.length} items`;
                    button.addEventListener('click', () => { currentVocabularyPart = partVocab; currentPartName = `Part ${i + 1}`; currentPartIndexGlobal = i; startGame(gameType); });
                    partButtonsContainer.appendChild(button);
                }
            }
        }

        function startGame(gameType) {
            activeGameType = gameType; 
            sessionScores[activeGameType] = 0; 
            selectedSpeechLangInGame = languageSelectorInGame.value || activeTargetStudyLanguage; 
            console.log(`Starting Game: ${gameType}. isEssentialsMode: ${isEssentialsMode}. Active Target Lang: ${activeTargetStudyLanguage}. Selected Speech Lang (In-Game): ${selectedSpeechLangInGame}`);
            
            if (!audioInitialized) initializeAudio();
            if (musicPlaying && Tone.Transport.state !== "started" && audioInitialized) Tone.Transport.start();
            resetPartStats(); 

            if (!currentVocabularyPart || currentVocabularyPart.length === 0 ) { noVocabularyMessage.textContent = `No vocabulary for this game.`; noVocabularyMessage.classList.remove('hidden'); gameArea.classList.remove('hidden'); [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, partSelectionContainer].forEach(el => el.classList.add('hidden')); hearItOutLoudToggleBtn.classList.add('hidden'); languageSelectionInGameContainer.classList.add('hidden'); return; }
            
            let sourceForGame = isBonusRound ? mistakeItems : currentVocabularyPart;
            if (gameType === 'multipleChoice' || gameType === 'matching' || gameType === 'talkToMe' || gameType === 'findTheWords') {
                currentGameActiveList = shuffleArray([...sourceForGame.filter(vItem => {
                    const threshold = (gameType === 'talkToMe' || gameType === 'findTheWords') ? MASTERED_THRESHOLD_SPEAK_LISTEN : LEARNED_THRESHOLD_GAMES;
                    return (vItem.correctCount || 0) < threshold;
                })]);
                currentGameSubRoundOffset = 0;
                 console.log(`Game Start: ${gameType}. currentGameActiveList length: ${currentGameActiveList.length} (unlearned items from part)`);
            }


            noVocabularyMessage.classList.add('hidden');
            [uploadSection, gameSelectionSection, partSelectionContainer, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, mainSelectionSection].forEach(el => el.classList.add('hidden'));
            gameArea.classList.remove('hidden');
            languageSelectionInGameContainer.classList.remove('hidden'); 
            [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden'));
            showGameInfoBar(); if(ttsGeneralStatus) ttsGeneralStatus.textContent = '';

            const showHearButton = gameType === 'flashcards' || gameType === 'matching' || gameType === 'multipleChoice' || gameType === 'findTheWords';
            hearItOutLoudToggleBtn.classList.toggle('hidden', !showHearButton);
            if(showHearButton) updateHearItOutLoudButton();

            const baseTitle = isEssentialsMode ? `${currentEssentialsCategoryName} - ` : (currentPartName ? `${currentPartName} - ` : 'Custom List - ');

            if (gameType === 'flashcards') { gameTitle.textContent = `${baseTitle}Flashcards`; flashcardGameContainer.classList.remove('hidden'); initFlashcards(currentVocabularyPart); }
            else if (gameType === 'matching') { gameTitle.textContent = `${baseTitle}Matching`; matchingGameContainer.classList.remove('hidden'); initMatchingGame(); } 
            else if (gameType === 'multipleChoice') { gameTitle.textContent = `${baseTitle}Multiple Choice`; multipleChoiceGameContainer.classList.remove('hidden'); initMultipleChoiceGame(); } 
            else if (gameType === 'typeTranslation') { gameTitle.textContent = `${baseTitle}Type Translation`; typeTranslationGameContainer.classList.remove('hidden'); initTypeTranslationGame(); }
            else if (gameType === 'talkToMe') { gameTitle.textContent = `${baseTitle}Talk to Me`; talkToMeGameContainer.classList.remove('hidden'); initTalkToMeGame(); }
            else if (gameType === 'fillInTheBlanks' && isEssentialsMode) { gameTitle.textContent = `${baseTitle}Fill in Blanks`; fillInTheBlanksGameContainer.classList.remove('hidden'); initFillInTheBlanksGame(); }
            else if (gameType === 'findTheWords') { gameTitle.textContent = `${baseTitle}Find the Words`; findTheWordsGameContainer.classList.remove('hidden'); initFindTheWordsGame(); }
        }
        function resetPartStats() { currentScore = 0; if (!isEssentialsMode) { mistakeItems = []; correctlyAnsweredItemsInPart.clear(); } isBonusRound = false; mistakesRemaining = MAX_MISTAKES; updateScoreDisplay(); setupMistakeTracker(); gameOverMessage.classList.add('hidden'); if (activeGameType) sessionScores[activeGameType] = 0; }
        function showFlashcardStackSelection() {
            if (!isEssentialsMode) { activeTargetStudyLanguage = csvUploadedTargetLanguage; selectedSpeechLangInGame = csvUploadedTargetLanguage; }
            else { selectedSpeechLangInGame = activeTargetStudyLanguage; }
            if(languageSelectorInGame) languageSelectorInGame.value = selectedSpeechLangInGame;
            languageSelectionInGameContainer.classList.remove('hidden');

            const sourceForStacks = isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName] : vocabulary;
            if (sourceForStacks.length === 0) { initFlashcards([]); gameTitle.textContent = 'Flashcards'; [uploadSection, gameSelectionSection, mainSelectionSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection].forEach(el => el.classList.add('hidden')); gameArea.classList.remove('hidden'); flashcardGameContainer.classList.remove('hidden'); flashcardStackSelectionContainer.classList.add('hidden'); document.getElementById('gameInfoBar').classList.add('hidden'); hearItOutLoudToggleBtn.classList.add('hidden'); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; return; }

            gameTitle.textContent = 'Flashcards - Select Stack';
            [uploadSection, gameSelectionSection, mainSelectionSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection].forEach(el => el.classList.add('hidden'));
            gameArea.classList.remove('hidden'); flashcardStackSelectionContainer.classList.remove('hidden');
            [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, partSelectionContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden'));
            document.getElementById('gameInfoBar').classList.remove('hidden');
            hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton(); if(ttsGeneralStatus) ttsGeneralStatus.textContent = '';

            stackButtonsContainer.innerHTML = '';
            const categories = {
                'All Vocabulary': sourceForStacks,
                'Words Only': sourceForStacks.filter(v => v.category === 'word'),
            };

            for (const [name, stack] of Object.entries(categories)) {
                if (stack.length > 0 || name === 'All Vocabulary') { 
                    const button = document.createElement('button');
                    button.className = 'btn stack-selection-btn p-3 sm:p-4 text-sm sm:text-md';
                    button.textContent = `${name} (${stack.length})`;
                    button.addEventListener('click', () => {
                        flashcardStackSelectionContainer.classList.add('hidden');
                        flashcardGameContainer.classList.remove('hidden');
                        gameTitle.textContent = `Flashcards - ${name}`;
                        showGameInfoBar(); 
                        hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton();
                        languageSelectionInGameContainer.classList.remove('hidden');
                        initFlashcards(stack);
                    });
                    stackButtonsContainer.appendChild(button);
                }
            }
        }
        function showGameInfoBar() { const el = document.getElementById('gameInfoBar'); if(el) el.classList.remove('hidden');}

        // --- Game Logic: Flashcards ---
        function initFlashcards(stackToUse) { currentFlashcardStack = stackToUse ? shuffleArray([...stackToUse]) : []; currentFlashcardIndex = 0; currentFlashcardSide = 'front'; if (currentFlashcardStack.length > 0) displayFlashcard(); else { flashcardFront.textContent = 'No vocabulary in this stack.'; flashcardBack.textContent = ''; flashcardCounter.textContent = '0/0'; prevCardBtn.disabled = true; nextCardBtn.disabled = true; } }
        function displayFlashcard() {
            if (currentFlashcardStack.length === 0 || currentFlashcardIndex < 0 || currentFlashcardIndex >= currentFlashcardStack.length) { flashcardFront.textContent = 'End of stack.'; flashcardBack.textContent = ''; return; }
            const item = currentFlashcardStack[currentFlashcardIndex];
            const { target, translation } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); 
            flashcardFront.textContent = truncateText(target); flashcardFront.title = target;
            flashcardBack.textContent = truncateText(translation); flashcardBack.title = translation;

            if (currentFlashcardSide === 'front') {
                flashcardFront.classList.remove('hidden'); flashcardBack.classList.add('hidden');
                if (hearItOutLoudEnabled && target) speakText(target, activeTargetStudyLanguage); 
            } else {
                flashcardFront.classList.add('hidden'); flashcardBack.classList.remove('hidden');
            }
            flashcardCounter.textContent = `${currentFlashcardIndex + 1} / ${currentFlashcardStack.length}`;
            prevCardBtn.disabled = currentFlashcardIndex === 0;
            nextCardBtn.disabled = currentFlashcardIndex === currentFlashcardStack.length - 1;
        }
        function flipFlashcard() { if (currentFlashcardStack.length === 0) return; currentFlashcardSide = (currentFlashcardSide === 'front') ? 'back' : 'front'; displayFlashcard(); }
        function nextFlashcard() { if (currentFlashcardIndex < currentFlashcardStack.length - 1) { currentFlashcardIndex++; currentFlashcardSide = 'front'; displayFlashcard(); } }
        function prevFlashcard() { if (currentFlashcardIndex > 0) { currentFlashcardIndex--; currentFlashcardSide = 'front'; displayFlashcard(); } }

        // --- Game Logic: Matching (with Sub-Rounds) ---
        function initMatchingGame(isBonus = false) { // isBonus is for mistake bonus round
            showGameInfoBar(); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton();
            languageSelectionInGameContainer.classList.remove('hidden'); if(languageSelectorInGame) languageSelectorInGame.value = selectedSpeechLangInGame;

            if (!isBonus) {
                isBonusRound = false;
                // currentGameActiveList is already set in startGame
                if (currentGameActiveList.length === 0) { // No unlearned items in the selected part
                     if (currentVocabularyPart.length > 0 && confirm(`You've mastered all terms in this set for Matching! Restart learning this set? (Resets learned counts).`)) {
                        currentVocabularyPart.forEach(vResetItem => {
                            const mainVocabItem = vocabulary.find(v => v.originalIndex === vResetItem.originalIndex && v.lang1 === vResetItem.lang1) || (isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName]?.find(v => v.originalIndex === vResetItem.originalIndex && v.lang1 === vResetItem.lang1) : null);
                            if (mainVocabItem) mainVocabItem.correctCount = 0;
                        });
                        currentGameActiveList = shuffleArray([...currentVocabularyPart.filter(vItem => (vItem.correctCount || 0) < LEARNED_THRESHOLD_GAMES)]);
                    } else {
                        matchingInstructions.textContent = 'All items learned or no items available.'; matchingGrid.innerHTML = '';
                        if (!isEssentialsMode) proceedToNextPartOrEnd('matching', currentPartIndexGlobal);
                        else handleRoundComplete('matching');
                        return;
                    }
                }
            } else { // Bonus round from mistakes
                isBonusRound = true;
                currentGameActiveList = shuffleArray([...mistakeItems]);
                gameTitle.textContent = `Matching - Bonus Round!`;
            }
            currentGameSubRoundOffset = 0;
            resetGameStats(); 
            startNextMatchingSubRound();
        }

        function startNextMatchingSubRound() {
            matchingGrid.innerHTML = ''; matchingFeedback.textContent = ''; selectedMatchCard = null; matchedPairs = 0;

            matchingGameActiveVocab = currentGameActiveList.slice(currentGameSubRoundOffset, currentGameSubRoundOffset + ITEMS_PER_SUB_ROUND);

            if (matchingGameActiveVocab.length === 0) {
                if (currentGameSubRoundOffset >= currentGameActiveList.length && currentGameActiveList.length > 0) {
                    handleRoundComplete('matching');
                } else {
                    matchingInstructions.textContent = isBonusRound ? 'No mistakes to practice for bonus!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!');
                    if (!isBonusRound && !isEssentialsMode) proceedToNextPartOrEnd('matching', currentPartIndexGlobal);
                    else if (isEssentialsMode && !isBonusRound) handleRoundComplete('matching');
                    else if (isBonusRound) { roundCompleteMessageDiv.innerHTML = `Bonus Round Complete! <br> (No mistakes were available to practice)`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('matching', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000); }
                }
                return;
            }

            pairsToMatch = matchingGameActiveVocab.length;
            const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Selection");
            const totalItemsInFullList = currentGameActiveList.length;
            const itemsPlayedSoFarInFullList = currentGameSubRoundOffset;
            matchingInstructions.textContent = `${isBonusRound ? 'Bonus Round:' : `Part: ${partInfo}`} Match. (${itemsPlayedSoFarInFullList + 1}-${Math.min(itemsPlayedSoFarInFullList + pairsToMatch, totalItemsInFullList)} of ${totalItemsInFullList})`;

            const targetLangCards = matchingGameActiveVocab.map((pair) => { const { target } = getEffectiveLanguages(pair, isEssentialsMode, activeTargetStudyLanguage); return { id: `target-${pair.originalIndex}-${pair.lang1.replace(/\s/g,'')}`, text: target, type: 'target', pairId: `${pair.originalIndex}-${pair.lang1.replace(/\s/g,'')}`, item: pair }; });
            const translationLangCards = matchingGameActiveVocab.map((pair) => { const { translation } = getEffectiveLanguages(pair, isEssentialsMode, activeTargetStudyLanguage); return { id: `translation-${pair.originalIndex}-${pair.lang1.replace(/\s/g,'')}`, text: translation, type: 'translation', pairId: `${pair.originalIndex}-${pair.lang1.replace(/\s/g,'')}`, item: pair }; });

            const allCards = shuffleArray([...targetLangCards, ...translationLangCards]);
            allCards.forEach(cardData => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card game-card p-2 sm:p-3'; 
                cardElement.textContent = truncateText(cardData.text);
                cardElement.title = cardData.text; 
                cardElement.dataset.id = cardData.id;
                cardElement.dataset.type = cardData.type;
                cardElement.dataset.pairId = cardData.pairId;
                cardElement.addEventListener('click', handleMatchCardClick);
                matchingGrid.appendChild(cardElement);
            });
            startQuestionTimer();
        }

        function handleMatchCardClick(event) {
            const clickedCard = event.currentTarget;
            if (hearItOutLoudEnabled && !clickedCard.classList.contains('matched') && clickedCard.dataset.type === 'target') {
                const textToSpeak = clickedCard.title; 
                if (textToSpeak) speakText(textToSpeak, activeTargetStudyLanguage);
            }
            if (mistakesRemaining === 0 && !isBonusRound) return; if (clickedCard.classList.contains('matched')) return;
            if (!selectedMatchCard) { clickedCard.classList.add('selected-match'); selectedMatchCard = clickedCard; matchingFeedback.textContent = ''; }
            else {
                if (selectedMatchCard === clickedCard) { selectedMatchCard.classList.remove('selected-match'); selectedMatchCard = null; return; } 
                if (selectedMatchCard.dataset.type === clickedCard.dataset.type) { selectedMatchCard.classList.remove('selected-match'); clickedCard.classList.add('selected-match'); selectedMatchCard = clickedCard; matchingFeedback.textContent = 'Select one of each language type.'; matchingFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-orange-500'; return; }

                const duration = getAnswerDuration();
                const itemForMistake = matchingGameActiveVocab.find(v => `${v.originalIndex}-${v.lang1.replace(/\s/g,'')}` === selectedMatchCard.dataset.pairId);

                if (selectedMatchCard.dataset.pairId === clickedCard.dataset.pairId) { 
                    handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, itemForMistake);
                    selectedMatchCard.classList.add('matched'); clickedCard.classList.add('matched');
                    selectedMatchCard.classList.remove('selected-match');
                    matchingFeedback.textContent = 'Correct Match!'; matchingFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-emerald-600';
                    selectedMatchCard = null; matchedPairs++;
                    if (matchedPairs === pairsToMatch) { 
                        currentGameSubRoundOffset += pairsToMatch;
                        setTimeout(() => startNextMatchingSubRound(), 1000); 
                    } else startQuestionTimer(); 
                } else { 
                    const gameOver = handleIncorrectAnswer(itemForMistake);
                    matchingFeedback.textContent = 'Incorrect. Try again.'; matchingFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-red-500';
                    selectedMatchCard.classList.add('incorrect-match-animation'); clickedCard.classList.add('incorrect-match-animation');
                    setTimeout(() => { if(selectedMatchCard) selectedMatchCard.classList.remove('incorrect-match-animation', 'selected-match'); clickedCard.classList.remove('incorrect-match-animation'); selectedMatchCard = null; if (gameOver && !isBonusRound) { } else startQuestionTimer(); }, 500);
                }
            }
        }

        // --- Game Logic: Multiple Choice (with Sub-Rounds) ---
        function initMultipleChoiceGame(isBonus = false) {
            showGameInfoBar(); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton();
            languageSelectionInGameContainer.classList.remove('hidden'); if(languageSelectorInGame) languageSelectorInGame.value = selectedSpeechLangInGame;
            if(mcqQuestion) mcqQuestion.classList.toggle('speakable-question', hearItOutLoudEnabled);
            
            if (!isBonus) {
                isBonusRound = false;
                // currentGameActiveList is set in startGame
                 if (currentGameActiveList.length === 0) {
                     if (currentVocabularyPart.length > 0 && confirm(`You've mastered all terms in this set for Multiple Choice! Restart learning this set? (Resets learned counts).`)) {
                        currentVocabularyPart.forEach(vResetItem => {
                            const mainVocabItem = vocabulary.find(v => v.originalIndex === vResetItem.originalIndex && v.lang1 === vResetItem.lang1) || (isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName]?.find(v => v.originalIndex === vResetItem.originalIndex && v.lang1 === vResetItem.lang1) : null);
                            if (mainVocabItem) mainVocabItem.correctCount = 0;
                        });
                        currentGameActiveList = shuffleArray([...currentVocabularyPart.filter(vItem => (vItem.correctCount || 0) < LEARNED_THRESHOLD_GAMES)]);
                    } else {
                        mcqInstructions.textContent = 'All items learned or no items available.'; mcqQuestion.textContent = ''; mcqOptions.innerHTML = '';
                        if (!isEssentialsMode) proceedToNextPartOrEnd('multipleChoice', currentPartIndexGlobal);
                        else handleRoundComplete('multipleChoice');
                        return;
                    }
                }
            } else {
                isBonusRound = true;
                currentGameActiveList = shuffleArray([...mistakeItems]);
                gameTitle.textContent = `MCQ - Bonus Round!`;
            }
            currentGameSubRoundOffset = 0;
            resetGameStats();
            startNextMcqSubRound();
        }
        
        function startNextMcqSubRound() {
            currentMcqIndex = 0; 
            mcqAnswered = false;
            nextMcqBtn.classList.add('hidden');
            mcqFeedback.textContent = '';
            mcqOptions.innerHTML = '';

            mcqGameActiveVocab = currentGameActiveList.slice(currentGameSubRoundOffset, currentGameSubRoundOffset + ITEMS_PER_SUB_ROUND);

            if (mcqGameActiveVocab.length === 0) {
                 if (currentGameSubRoundOffset >= currentGameActiveList.length && currentGameActiveList.length > 0) {
                    handleRoundComplete('multipleChoice'); 
                } else {
                    mcqQuestion.textContent = isBonusRound ? 'No mistakes to practice for bonus!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!');
                    if (!isBonusRound && !isEssentialsMode) proceedToNextPartOrEnd('multipleChoice', currentPartIndexGlobal);
                    else if (isEssentialsMode && !isBonusRound) handleRoundComplete('multipleChoice');
                    else if (isBonusRound) { roundCompleteMessageDiv.innerHTML = `Bonus Round Complete! <br> (No mistakes were available to practice)`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('multipleChoice', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000); }
                }
                return;
            }
            
            const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List");
            const totalItemsInFullList = currentGameActiveList.length;
            const itemsPlayedSoFarInFullList = currentGameSubRoundOffset;
            mcqInstructions.textContent = `${isBonusRound ? 'Bonus:' : `Part: ${partInfo}`} Choose translation. (${itemsPlayedSoFarInFullList + 1}-${Math.min(itemsPlayedSoFarInFullList + mcqGameActiveVocab.length, totalItemsInFullList)} of ${totalItemsInFullList})`;
            
            displayMcq();
        }

        function displayMcq() {
            mcqAnswered = false; nextMcqBtn.classList.add('hidden'); mcqFeedback.textContent = ''; mcqOptions.innerHTML = '';
            if(mcqQuestion) mcqQuestion.classList.toggle('speakable-question', hearItOutLoudEnabled);

            if (currentMcqIndex >= mcqGameActiveVocab.length) { 
                currentGameSubRoundOffset += mcqGameActiveVocab.length;
                startNextMcqSubRound(); 
                return;
            }
            if (mistakesRemaining === 0 && !isBonusRound) return; 

            const currentPair = mcqGameActiveVocab[currentMcqIndex];
            const { target, translation } = getEffectiveLanguages(currentPair, isEssentialsMode, activeTargetStudyLanguage);
            mcqQuestion.textContent = truncateText(target); mcqQuestion.title = target;
            if (hearItOutLoudEnabled && target) speakText(target, activeTargetStudyLanguage);

            const correctAnswer = translation;
            let options = [correctAnswer];
            const allPossibleTranslations = (
                isEssentialsMode ?
                Object.values(essentialsVocabularyData).flat().map(p => getEffectiveLanguages(p, true, activeTargetStudyLanguage).translation) :
                vocabulary.map(p => p.lang2) 
            ).filter(t => t !== undefined && t !== null && typeof t === 'string');

            const distractors = shuffleArray(allPossibleTranslations.filter(text => text.toLowerCase() !== correctAnswer.toLowerCase())).slice(0, 3);
            options.push(...distractors);
            while (options.length < Math.min(2, allPossibleTranslations.length) && options.length < 4) options.push(`Option ${options.length + 1}`); 
            options = shuffleArray(options.slice(0,4)); 

            options.forEach(optionText => {
                const optionButton = document.createElement('button');
                optionButton.className = 'btn mcq-option-btn'; 
                optionButton.textContent = truncateText(optionText);
                optionButton.title = optionText; 
                optionButton.addEventListener('click', () => handleMcqAnswer(optionText, correctAnswer, optionButton, currentPair));
                mcqOptions.appendChild(optionButton);
            });
            const itemsPlayedInPartSoFar = currentGameSubRoundOffset + currentMcqIndex;
            mcqInstructions.textContent = `Q ${itemsPlayedInPartSoFar + 1}/${currentGameActiveList.length}. Choose translation for: ${truncateText(target)}`;
            startQuestionTimer();
        }
        function handleMcqAnswer(selectedAnswer, correctAnswer, buttonElement, item) { if (mcqAnswered || (mistakesRemaining === 0 && !isBonusRound)) return; mcqAnswered = true; const duration = getAnswerDuration(); mcqOptions.querySelectorAll('.mcq-option-btn').forEach(btn => { btn.disabled = true; if (btn.title.toLowerCase() === correctAnswer.toLowerCase()) { btn.classList.add('correct-answer'); } }); if (buttonElement.title.toLowerCase() === correctAnswer.toLowerCase()) { handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, item); mcqFeedback.textContent = 'Correct!'; mcqFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-emerald-600'; if (currentMcqIndex >= mcqGameActiveVocab.length - 1) { nextMcqBtn.classList.remove('hidden'); nextMcqBtn.textContent = "Next"; } else { setTimeout(() => { nextMcqQuestion(); }, 1500); } } else { const gameOver = handleIncorrectAnswer(item); mcqFeedback.textContent = `Incorrect. The answer was: ${truncateText(correctAnswer)}`; mcqFeedback.title = `Full answer: ${correctAnswer}`; mcqFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-red-500'; buttonElement.classList.add('incorrect-answer'); nextMcqBtn.classList.remove('hidden'); if (currentMcqIndex >= mcqGameActiveVocab.length - 1) nextMcqBtn.textContent = "Next"; else nextMcqBtn.textContent = "Next Question"; if (gameOver && !isBonusRound) { } } }
        function nextMcqQuestion() { if (mistakesRemaining === 0 && !isBonusRound) { initMultipleChoiceGame(false); return; } currentMcqIndex++; if (mcqOptions) mcqOptions.querySelectorAll('.mcq-option-btn').forEach(btn => btn.disabled = false); displayMcq(); }

        // --- Game Logic: Type Translation ---
        function initTypeTranslationGame(isBonus = false) { showGameInfoBar(); hearItOutLoudToggleBtn.classList.add('hidden'); languageSelectionInGameContainer.classList.add('hidden'); let sourceVocabForThisGame = isBonus ? mistakeItems : currentVocabularyPart; if (!isBonus) { isBonusRound = false; typeTransGameActiveVocab = shuffleArray([...sourceVocabForThisGame]); } else { isBonusRound = true; typeTransGameActiveVocab = shuffleArray([...sourceVocabForThisGame]); gameTitle.textContent = `Type Translation - Bonus Round!`; } resetPartStats(); currentTypeTranslationIndex = 0; typeTranslationAnswered = false; hintUsedForCurrentTypeTranslation = false; nextTypeTranslationBtn.classList.add('hidden'); typeTranslationFeedback.textContent = ''; typeTranslationInput.value = ''; typeTranslationInput.disabled = false; checkTypeTranslationBtn.disabled = false; hintTypeTranslationBtn.disabled = false; typeTranslationHintDisplay.textContent = ''; if (typeTransGameActiveVocab.length === 0) { typeTranslationPhrase.textContent = isBonus ? 'No mistakes to practice!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!'); typeTranslationCounter.textContent = '0/0'; if (!isBonus && !isEssentialsMode) proceedToNextPartOrEnd('typeTranslation', currentPartIndexGlobal); else if (isEssentialsMode && !isBonus) handleRoundComplete('typeTranslation'); return; } const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List"); typeTranslationInstructions.textContent = `${isBonus ? 'Bonus:' : `Part: ${partInfo}`} Type Target Language translation for word/phrase shown. (${typeTransGameActiveVocab.length} items)`; displayTypeTranslationQuestion(); }
        function displayTypeTranslationQuestion() { typeTranslationAnswered = false; hintUsedForCurrentTypeTranslation = false; nextTypeTranslationBtn.classList.add('hidden'); typeTranslationInput.value = ''; typeTranslationInput.disabled = false; checkTypeTranslationBtn.disabled = false; hintTypeTranslationBtn.disabled = false; typeTranslationHintDisplay.textContent = ''; typeTranslationFeedback.textContent = ''; typeTranslationInput.focus(); if (currentTypeTranslationIndex >= typeTransGameActiveVocab.length) { if (isBonusRound) { roundCompleteMessageDiv.innerHTML = `Bonus Round Complete! <br> Score for ${currentPartName || currentEssentialsCategoryName}: ${currentScore}`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('typeTranslation', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000); } else { handleRoundComplete('typeTranslation'); } return; } if (mistakesRemaining === 0 && !isBonusRound) return; const pair = typeTransGameActiveVocab[currentTypeTranslationIndex]; const { translation } = getEffectiveLanguages(pair, isEssentialsMode, activeTargetStudyLanguage); typeTranslationPhrase.textContent = truncateText(translation); typeTranslationPhrase.title = translation; typeTranslationCounter.textContent = `${currentTypeTranslationIndex + 1} / ${typeTransGameActiveVocab.length}`; startQuestionTimer(); }
        function showTypeTranslationHint() { if (typeTranslationAnswered || hintUsedForCurrentTypeTranslation || currentTypeTranslationIndex >= typeTransGameActiveVocab.length) return; const { target } = getEffectiveLanguages(typeTransGameActiveVocab[currentTypeTranslationIndex], isEssentialsMode, activeTargetStudyLanguage); const correctAnswer = target.trim(); if (correctAnswer.length > 0) { typeTranslationHintDisplay.textContent = `Hint: Starts with "${correctAnswer[0]}"`; hintUsedForCurrentTypeTranslation = true; hintTypeTranslationBtn.disabled = true; } }
        function checkTypeTranslationAnswer() { if (typeTranslationAnswered || (mistakesRemaining === 0 && !isBonusRound) || currentTypeTranslationIndex >= typeTransGameActiveVocab.length) return; const duration = getAnswerDuration(); const userAnswer = typeTranslationInput.value.trim().toLowerCase(); const currentItem = typeTransGameActiveVocab[currentTypeTranslationIndex]; const { target } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); const correctAnswer = target.trim().toLowerCase(); typeTranslationAnswered = true; typeTranslationInput.disabled = true; checkTypeTranslationBtn.disabled = true; hintTypeTranslationBtn.disabled = true; nextTypeTranslationBtn.classList.remove('hidden'); nextTypeTranslationBtn.focus(); if (userAnswer === correctAnswer) { handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, currentItem); typeTranslationFeedback.textContent = 'Correct!'; typeTranslationFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-emerald-600'; typeTranslationInput.classList.add('border-emerald-500'); typeTranslationInput.classList.remove('border-red-500'); } else { const gameOver = handleIncorrectAnswer(currentItem); typeTranslationFeedback.textContent = `Not quite. Correct: ${target}`; typeTranslationFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-red-500'; typeTranslationInput.classList.add('border-red-500'); typeTranslationInput.classList.remove('border-emerald-500'); if (gameOver && !isBonusRound) { } } }
        function nextTypeTranslationQuestion() { if (mistakesRemaining === 0 && !isBonusRound) { initTypeTranslationGame(false); return; } currentTypeTranslationIndex++; typeTranslationInput.classList.remove('border-red-500', 'border-emerald-500'); displayTypeTranslationQuestion(); }

        // --- Game Logic: Fill In The Blanks (Essentials Mode Only) ---
        function initFillInTheBlanksGame() { if (!isEssentialsMode) { fillInTheBlanksSentence.textContent = "This game is available for 'Study Essentials' only."; disableAllGameInteractions(); return; } showGameInfoBar(); hearItOutLoudToggleBtn.classList.add('hidden'); languageSelectionInGameContainer.classList.add('hidden'); isBonusRound = false; fillBlanksGameActiveVocab = shuffleArray([...currentVocabularyPart]) .filter(item => item.sentence && item.sentence.includes("____")) .slice(0, MAX_GAME_ITEMS_FILL_BLANKS); resetGameStats(); setupMistakeTracker(); currentFillBlanksIndex = 0; fillBlanksAnswered = false; nextFillInTheBlanksBtn.classList.add('hidden'); fillInTheBlanksFeedback.textContent = ''; fillInTheBlanksInput.value = ''; fillInTheBlanksInput.disabled = false; checkFillInTheBlanksBtn.disabled = false; if (fillBlanksGameActiveVocab.length === 0) { fillInTheBlanksSentence.textContent = `No "fill in the blank" items in ${currentEssentialsCategoryName}. Sentences must contain '____'.`; fillInTheBlanksCounter.textContent = '0/0'; handleRoundComplete('fillInTheBlanks'); return; } fillInTheBlanksInstructions.textContent = `Part: ${currentEssentialsCategoryName}. Fill in the blank. (${fillBlanksGameActiveVocab.length} items)`; displayFillInTheBlanksQuestion(); }
        function displayFillInTheBlanksQuestion() { fillBlanksAnswered = false; nextFillInTheBlanksBtn.classList.add('hidden'); fillInTheBlanksInput.value = ''; fillInTheBlanksInput.disabled = false; checkFillInTheBlanksBtn.disabled = false; fillInTheBlanksFeedback.textContent = ''; fillInTheBlanksInput.focus(); if (currentFillBlanksIndex >= fillBlanksGameActiveVocab.length) { handleRoundComplete('fillInTheBlanks'); return; } if (mistakesRemaining === 0) return; const currentItem = fillBlanksGameActiveVocab[currentFillBlanksIndex]; const { target: blankWordForSentence } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); const sentenceParts = currentItem.sentence.split("____"); fillInTheBlanksSentence.innerHTML = ''; fillInTheBlanksSentence.appendChild(document.createTextNode(sentenceParts[0])); const blankPlaceholder = document.createElement('span'); blankPlaceholder.className = 'blank-placeholder'; blankPlaceholder.textContent = '(blank)'; fillInTheBlanksSentence.appendChild(blankPlaceholder); if (sentenceParts.length > 1) fillInTheBlanksSentence.appendChild(document.createTextNode(sentenceParts[1])); fillInTheBlanksSentence.dataset.fullSentence = currentItem.sentence; fillInTheBlanksSentence.dataset.blankWord = blankWordForSentence; fillInTheBlanksCounter.textContent = `${currentFillBlanksIndex + 1} / ${fillBlanksGameActiveVocab.length}`; startQuestionTimer(); }
        function checkFillInTheBlanksAnswer() { if (fillBlanksAnswered || mistakesRemaining === 0 || currentFillBlanksIndex >= fillBlanksGameActiveVocab.length) return; const duration = getAnswerDuration(); const userAnswer = fillInTheBlanksInput.value.trim().toLowerCase(); const currentItem = fillBlanksGameActiveVocab[currentFillBlanksIndex]; const { target: correctAnswer } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); const correctAnswerLower = correctAnswer.trim().toLowerCase(); fillBlanksAnswered = true; fillInTheBlanksInput.disabled = true; checkFillInTheBlanksBtn.disabled = true; nextFillInTheBlanksBtn.classList.remove('hidden'); nextFillInTheBlanksBtn.focus(); if (userAnswer === correctAnswerLower) { handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, currentItem); fillInTheBlanksFeedback.textContent = 'Correct!'; fillInTheBlanksFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-emerald-600'; fillInTheBlanksInput.classList.add('border-emerald-500'); fillInTheBlanksInput.classList.remove('border-red-500'); } else { const gameOver = handleIncorrectAnswer(currentItem); fillInTheBlanksFeedback.textContent = `Not quite. Correct answer: ${correctAnswer}`; fillInTheBlanksFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-red-500'; fillInTheBlanksInput.classList.add('border-red-500'); fillInTheBlanksInput.classList.remove('border-emerald-500'); if (gameOver) { } } }
        function nextFillInTheBlanksQuestion() { if (mistakesRemaining === 0) { initFillInTheBlanksGame(); return; } currentFillBlanksIndex++; fillInTheBlanksInput.classList.remove('border-red-500', 'border-emerald-500'); displayFillInTheBlanksQuestion(); }

        // --- Game Logic: Find The Words (with Sub-Sessions from currentGameActiveList) ---
        function initFindTheWordsGame(isBonus = false) {
            showGameInfoBar(); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton();
            languageSelectionInGameContainer.classList.remove('hidden'); if(languageSelectorInGame) languageSelectorInGame.value = selectedSpeechLangInGame;

            if (!isBonus) {
                isBonusRound = false;
                // currentGameActiveList is set in startGame
                if (currentGameActiveList.length < FIND_WORDS_REQUIRED_VOCAB) {
                    findTheWordsGrid.innerHTML = `<p class="col-span-full text-center text-red-500">Not enough vocabulary for 'Find the Words' (need at least ${FIND_WORDS_REQUIRED_VOCAB} unique target language items from the current selection).</p>`;
                    disableAllGameInteractions();
                    setTimeout(() => { // Give user time to read message
                        if (!isEssentialsMode) proceedToNextPartOrEnd('findTheWords', currentPartIndexGlobal);
                        else handleRoundComplete('findTheWords');
                    }, 3000);
                    return;
                }
            } else {
                isBonusRound = true;
                currentGameActiveList = shuffleArray([...mistakeItems]); // Use mistakes for bonus
                if (currentGameActiveList.length < FIND_WORDS_REQUIRED_VOCAB) {
                     findTheWordsGrid.innerHTML = `<p class="col-span-full text-center text-red-500">Not enough mistake items (${FIND_WORDS_REQUIRED_VOCAB} needed) for a Find The Words bonus round.</p>`;
                     disableAllGameInteractions();
                     setTimeout(() => {roundCompleteMessageDiv.innerHTML = `Bonus Round Skipped! <br> (Not enough mistakes for Find The Words)`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('findTheWords', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000);}, 2000);
                     return;
                }
                gameTitle.textContent = `Find The Words - Bonus Round!`;
            }
            currentGameSubRoundOffset = 0; // For FindTheWords, this offset is for the currentGameActiveList
            resetGameStats(); 
            setupMistakeTracker();
            startNextFindTheWordsSubSession();
        }

        function startNextFindTheWordsSubSession() {
            // Take a slice from the overall active list for this "sub-session" of Find The Words
            // This slice will be used for the MAX_FIND_WORDS_ROUNDS
            findWordsSessionPool = currentGameActiveList.slice(currentGameSubRoundOffset, currentGameSubRoundOffset + Math.max(ITEMS_PER_SUB_ROUND, FIND_WORDS_REQUIRED_VOCAB));

            if (findWordsSessionPool.length < FIND_WORDS_REQUIRED_VOCAB) {
                 if (currentGameSubRoundOffset >= currentGameActiveList.length && currentGameActiveList.length > 0) {
                    handleRoundComplete('findTheWords'); // All words from the part have been processed
                } else {
                     findTheWordsGrid.innerHTML = `<p class="col-span-full text-center text-red-500">Not enough remaining words for a full 'Find the Words' session.</p>`;
                     setTimeout(() => handleRoundComplete('findTheWords'), 2500);
                }
                return;
            }
            
            currentFindWordsRound = 0; // Reset for the new pool of words
            findWordsSelectedWords = []; 
            nextFindTheWordsRoundBtn.classList.add('hidden'); 
            sendFindTheWordsBtn.disabled = true; 
            findTheWordsFeedback.textContent = ''; 
            replayFindTheWordsAudioBtn.disabled = false;
            const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List");
            const totalItemsInFullList = currentGameActiveList.length;
            const itemsPlayedSoFarInFullList = currentGameSubRoundOffset;
            gameTitle.textContent = `${isBonusRound ? "Bonus: " : ""}${partInfo} - Find The Words (Set ${Math.floor(currentGameSubRoundOffset / Math.max(ITEMS_PER_SUB_ROUND, FIND_WORDS_REQUIRED_VOCAB)) + 1})`;
            
            displayFindTheWordsQuestion();
        }


        async function speakFindTheWordsTargets(wordsToSpeakArray, initialDelay = 1000) { if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = true; if (initialDelay > 0) await new Promise(resolve => setTimeout(resolve, initialDelay)); try { for (let i = 0; i < wordsToSpeakArray.length; i++) { const item = wordsToSpeakArray[i]; const { target: textToSpeak } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); if (textToSpeak) await speakText(textToSpeak, activeTargetStudyLanguage); if (i < wordsToSpeakArray.length - 1) await new Promise(resolve => setTimeout(resolve, 750)); } } catch (error) { console.error("Error in speakFindTheWordsTargets:", error); if(ttsGeneralStatus) ttsGeneralStatus.textContent = "Audio error."; } finally { if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = false; } }
        
        function displayFindTheWordsQuestion() {
            // Uses findWordsSessionPool for this set of MAX_FIND_WORDS_ROUNDS
            let unmasteredInPool = findWordsSessionPool.filter(item => (item.correctCount || 0) < MASTERED_THRESHOLD_SPEAK_LISTEN);
            if (unmasteredInPool.length < WORDS_PER_FIND_WORDS_TARGET) { 
                // Not enough unmastered words in the current pool for a target set
                // This means this sub-session of Find The Words is done. Move to next sub-session or complete.
                currentGameSubRoundOffset += findWordsSessionPool.length;
                if (currentGameSubRoundOffset >= currentGameActiveList.length) {
                    handleRoundComplete('findTheWords'); // All words from the main list processed
                } else {
                    startNextFindTheWordsSubSession(); // Get next batch of words
                }
                return;
            }
            findWordsTargetWords = shuffleArray(unmasteredInPool).slice(0, WORDS_PER_FIND_WORDS_TARGET);
            findWordsSelectedWords = []; if(findTheWordsGrid) findTheWordsGrid.innerHTML = ''; if(sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = true; if(nextFindTheWordsRoundBtn) nextFindTheWordsRoundBtn.classList.add('hidden'); if(findTheWordsFeedback) findTheWordsFeedback.textContent = ''; if(replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = false; 
            
            if (currentFindWordsRound >= MAX_FIND_WORDS_ROUNDS) { // Finished 5 rounds for current pool
                currentGameSubRoundOffset += findWordsSessionPool.length;
                 if (currentGameSubRoundOffset >= currentGameActiveList.length) {
                    handleRoundComplete('findTheWords'); // All words from the main list processed
                } else {
                    startNextFindTheWordsSubSession(); // Get next batch of words
                }
                return;
            } 
            
            if(findTheWordsInstructions) findTheWordsInstructions.textContent = `Listen and select the ${WORDS_PER_FIND_WORDS_TARGET} words you hear (in the Target Language).`; 
            if(findTheWordsRoundCounter) findTheWordsRoundCounter.textContent = `Round: ${currentFindWordsRound + 1}/${MAX_FIND_WORDS_ROUNDS}`; 
            
            let remainingVocabForDistractors = shuffleArray([...findWordsSessionPool].filter(item => !findWordsTargetWords.some(target => target.originalIndex === item.originalIndex && target.lang1 === item.lang1) )); 
            const distractors = remainingVocabForDistractors.slice(0, WORDS_PER_FIND_WORDS_DISPLAY - WORDS_PER_FIND_WORDS_TARGET); 
            findWordsCurrentChoices = shuffleArray([...findWordsTargetWords, ...distractors]); 
            findWordsCurrentChoices.forEach(wordObj => { const cardElement = document.createElement('div'); cardElement.className = 'card game-card p-2 sm:p-3'; const { target: displayText } = getEffectiveLanguages(wordObj, isEssentialsMode, activeTargetStudyLanguage); cardElement.textContent = truncateText(displayText); cardElement.title = displayText; cardElement.dataset.word = displayText; cardElement.addEventListener('click', handleFindWordCardClick); if(findTheWordsGrid) findTheWordsGrid.appendChild(cardElement); }); 
            speakFindTheWordsTargets(findWordsTargetWords, 1000); 
            startQuestionTimer();
        }
        function handleFindWordCardClick(event) { if (findTheWordsFeedback && (findTheWordsFeedback.textContent.includes("Correct") || findTheWordsFeedback.textContent.includes("Incorrect"))) { return; } const cardElement = event.currentTarget; const word = cardElement.dataset.word; if (cardElement.classList.contains('selected-find-word')) { cardElement.classList.remove('selected-find-word'); findWordsSelectedWords = findWordsSelectedWords.filter(sw => sw !== word); } else { if (findWordsSelectedWords.length < WORDS_PER_FIND_WORDS_TARGET) { cardElement.classList.add('selected-find-word'); findWordsSelectedWords.push(word); } } if (sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = findWordsSelectedWords.length !== WORDS_PER_FIND_WORDS_TARGET; }
        function checkFindTheWordsAnswer() { if (findWordsSelectedWords.length !== WORDS_PER_FIND_WORDS_TARGET) return; if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = true; if (sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = true; const sortedSelected = [...findWordsSelectedWords].sort((a,b) => a.localeCompare(b, activeTargetStudyLanguage, { sensitivity: 'base' })); const sortedTargets = findWordsTargetWords.map(w => { const { target } = getEffectiveLanguages(w, isEssentialsMode, activeTargetStudyLanguage); return target; }).sort((a,b) => a.localeCompare(b, activeTargetStudyLanguage, { sensitivity: 'base' })); let isCorrect = sortedSelected.length === sortedTargets.length && sortedSelected.every((value, index) => value.toLowerCase() === sortedTargets[index].toLowerCase()); if (isCorrect) { findWordsTargetWords.forEach(item => handleCorrectAnswer(false, item, POINTS_SLOW_CORRECT / findWordsTargetWords.length)); if (findTheWordsFeedback) { findTheWordsFeedback.textContent = 'Correct!'; findTheWordsFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-emerald-600'; } } else { handleIncorrectAnswer(null, POINTS_INCORRECT); if (findTheWordsFeedback) { findTheWordsFeedback.textContent = 'Incorrect. Try the next round.'; findTheWordsFeedback.className = 'text-center font-medium mt-3 sm:mt-4 h-5 sm:h-6 text-red-500'; } } if (nextFindTheWordsRoundBtn) { nextFindTheWordsRoundBtn.classList.remove('hidden'); if (currentFindWordsRound + 1 >= MAX_FIND_WORDS_ROUNDS) { nextFindTheWordsRoundBtn.textContent = "Finish This Set"; } else { nextFindTheWordsRoundBtn.textContent = "Next Round"; } } }
        function nextFindTheWordsRound() { currentFindWordsRound++; displayFindTheWordsQuestion(); } // displayFindTheWordsQuestion handles logic for finishing MAX_ROUNDS or moving to next sub-session

        // --- Game Logic: Talk to Me (with Sub-Rounds) ---
        function initTalkToMeGame(isBonus = false) {
            showGameInfoBar(); hearItOutLoudToggleBtn.classList.add('hidden'); 
            languageSelectionInGameContainer.classList.remove('hidden'); if(languageSelectorInGame) languageSelectorInGame.value = selectedSpeechLangInGame;

            if (!isBonus) {
                isBonusRound = false;
                // currentGameActiveList is set in startGame
                if (currentGameActiveList.length === 0) {
                     if (currentVocabularyPart.length > 0 && confirm("You've mastered all phrases for Talk To Me in this set! Restart learning this set? (Resets learned counts).")) { 
                        currentVocabularyPart.forEach(vResetItem => { const mainV = vocabulary.find(v=>v.originalIndex === vResetItem.originalIndex && v.lang1 === vResetItem.lang1) || (isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName]?.find(v=>v.originalIndex === vResetItem.originalIndex && v.lang1 === vResetItem.lang1):null); if(mainV) mainV.correctCount = 0; });
                        currentGameActiveList = shuffleArray([...currentVocabularyPart.filter(item => (item.correctCount || 0) < MASTERED_THRESHOLD_SPEAK_LISTEN)]);
                    } else {
                        talkToMePhraseText.textContent = 'All items learned or no items available!'; talkToMeCounter.textContent = '0/0';
                        if (!isEssentialsMode) proceedToNextPartOrEnd('talkToMe', currentPartIndexGlobal);
                        else handleRoundComplete('talkToMe');
                        return;
                    }
                }
            } else { 
                isBonusRound = true; 
                currentGameActiveList = shuffleArray([...mistakeItems]); 
                gameTitle.textContent = `Talk to Me - Bonus Round!`; 
            }
            currentGameSubRoundOffset = 0;
            resetPartStats();
            startNextTalkToMeSubRound();
        }

        function startNextTalkToMeSubRound() {
            currentTalkToMeIndex = 0;
            attemptCountForCurrentTalkToMeItem = 0; 
            isListening = false; 
            if(listenBtnText) listenBtnText.textContent = 'Start Listening'; 
            if(listenBtn) { listenBtn.classList.remove('listening', 'btn-danger'); listenBtn.classList.add('btn-primary'); listenBtn.disabled = false; } 
            if(nextTalkToMeBtn) nextTalkToMeBtn.classList.add('hidden'); 
            if(talkToMeFeedback) talkToMeFeedback.textContent = ''; 
            if(talkToMeRecognizedText) talkToMeRecognizedText.textContent = '...'; 
            if(talkToMeReferenceContainer) talkToMeReferenceContainer.classList.add('hidden'); 
            if(speechApiStatus) speechApiStatus.textContent = '';

            talkToMeActiveVocab = currentGameActiveList.slice(currentGameSubRoundOffset, currentGameSubRoundOffset + ITEMS_PER_SUB_ROUND);

            if (talkToMeActiveVocab.length === 0) {
                if (currentGameSubRoundOffset >= currentGameActiveList.length && currentGameActiveList.length > 0) {
                    handleRoundComplete('talkToMe');
                } else {
                    talkToMePhraseText.textContent = isBonusRound ? 'No mistakes to practice for bonus!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!');
                    talkToMeCounter.textContent = '0/0';
                    if (!isBonusRound && !isEssentialsMode) proceedToNextPartOrEnd('talkToMe', currentPartIndexGlobal);
                    else if (isEssentialsMode && !isBonusRound) handleRoundComplete('talkToMe');
                    else if (isBonusRound) { roundCompleteMessageDiv.innerHTML = `Bonus Round Complete! <br> (No mistakes were available to practice)`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('talkToMe', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000); }
                }
                return;
            }

            const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List");
            const totalItemsInFullList = currentGameActiveList.length;
            const itemsPlayedSoFarInFullList = currentGameSubRoundOffset;
            if(talkToMeInstructions) talkToMeInstructions.textContent = `${isBonusRound ? 'Bonus:' : `Part: ${partInfo}`} Read aloud. (${itemsPlayedSoFarInFullList + 1}-${Math.min(itemsPlayedSoFarInFullList + talkToMeActiveVocab.length, totalItemsInFullList)} of ${totalItemsInFullList})`;
            
            setupSpeechRecognition(); 
            displayTalkToMeItem();
        }


        function displayTalkToMeItem() {
            if (currentTalkToMeIndex >= talkToMeActiveVocab.length) { // Current sub-round finished
                currentGameSubRoundOffset += talkToMeActiveVocab.length;
                startNextTalkToMeSubRound(); // Attempt to start next sub-round or finish part
                return;
            }

            if (mistakesRemaining === 0 && !isBonusRound) return;
            attemptCountForCurrentTalkToMeItem = 0;
            const item = talkToMeActiveVocab[currentTalkToMeIndex];
            const { target, translation } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); 
            if(talkToMePhraseText) talkToMePhraseText.textContent = target;
            if(talkToMePhraseToRead) talkToMePhraseToRead.title = target; 
            if(talkToMeReferenceDisplay) talkToMeReferenceDisplay.textContent = translation;
            if(talkToMeReferenceLabel) talkToMeReferenceLabel.textContent = isEssentialsMode ? (activeTargetStudyLanguage.startsWith('es') || activeTargetStudyLanguage.startsWith('fr') ? 'English Original:' : 'Translation:') : 'Your Language Translation:';
            if(talkToMeReferenceContainer) talkToMeReferenceContainer.classList.add('hidden');
            if(talkToMeRecognizedText) talkToMeRecognizedText.textContent = '...';
            if(talkToMeFeedback) talkToMeFeedback.textContent = '';
            if(listenBtn) listenBtn.disabled = false;
            if(nextTalkToMeBtn) nextTalkToMeBtn.classList.add('hidden');
            
            const itemsPlayedInPartSoFar = currentGameSubRoundOffset + currentTalkToMeIndex;
            if(talkToMeCounter) talkToMeCounter.textContent = `${itemsPlayedInPartSoFar + 1} / ${currentGameActiveList.length}`;
            startQuestionTimer();
        }
        function setupSpeechRecognition() {
            const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognitionAPI) { if(speechApiStatus) speechApiStatus.textContent = "Speech API not supported by your browser."; if(listenBtn) listenBtn.disabled = true; return; }
            recognition = new SpeechRecognitionAPI();
            recognition.lang = selectedSpeechLangInGame || activeTargetStudyLanguage; 
            recognition.interimResults = false; recognition.maxAlternatives = 1;
            recognition.onresult = (event) => { const spokenText = event.results[event.results.length - 1][0].transcript.trim(); if(talkToMeRecognizedText) talkToMeRecognizedText.textContent = spokenText; processSpokenText(spokenText); };
            recognition.onerror = (event) => { if(speechApiStatus) speechApiStatus.textContent = `Recognition error: ${event.error}. Try checking mic permissions.`; console.error("Speech error:", event.error, "Lang:", recognition.lang); if (isListening && typeof toggleListeningSpeechUIUpdate === "function") toggleListeningSpeechUIUpdate(false);};
            recognition.onend = () => { if (isListening && typeof toggleListeningSpeechUIUpdate === "function") toggleListeningSpeechUIUpdate(false);};
        }
        function toggleListeningSpeech() {
            if (!recognition) { if (speechApiStatus) speechApiStatus.textContent = "Speech recognition not initialized."; return; }
            if (isListening) { recognition.stop(); }
            else {
                try {
                    recognition.lang = selectedSpeechLangInGame || activeTargetStudyLanguage; 
                    recognition.start(); toggleListeningSpeechUIUpdate(true);
                } catch (e) { console.error("Error starting recognition:", e); if (speechApiStatus) speechApiStatus.textContent = "Could not start listening. Try again or check mic."; toggleListeningSpeechUIUpdate(false); }
            }
        }
        function toggleListeningSpeechUIUpdate(nowListening) { isListening = nowListening; if (listenBtn && listenBtnText) { if (isListening) { listenBtnText.textContent = 'Stop Listening'; listenBtn.classList.add('listening', 'btn-danger'); listenBtn.classList.remove('btn-primary'); if (talkToMeFeedback) talkToMeFeedback.textContent = "Speak now..."; if (talkToMeRecognizedText) talkToMeRecognizedText.textContent = "..."; } else { listenBtnText.textContent = 'Start Listening'; listenBtn.classList.remove('listening', 'btn-danger'); listenBtn.classList.add('btn-primary'); } } }
        function processSpokenText(spokenText) { if ((mistakesRemaining === 0 && !isBonusRound) || currentTalkToMeIndex >= talkToMeActiveVocab.length) return; attemptCountForCurrentTalkToMeItem++; const currentItem = talkToMeActiveVocab[currentTalkToMeIndex]; const { target: targetTextForComparisonOriginal } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); let targetTextForComparison = targetTextForComparisonOriginal.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g,"").replace(/\s{2,}/g," ").trim(); const recognizedNormalized = spokenText.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g,"").replace(/\s{2,}/g," ").trim(); const targetWordsSet = new Set(targetTextForComparison.split(" ").filter(w => w.length > 0)); const recognizedWordsSet = new Set(recognizedNormalized.split(" ").filter(w => w.length > 0)); let matchingWords = 0; recognizedWordsSet.forEach(word => { if (targetWordsSet.has(word)) matchingWords++; }); const similarity = targetWordsSet.size > 0 ? (matchingWords / targetWordsSet.size) : (recognizedNormalized === "" && targetTextForComparison === "" ? 1 : 0); if(talkToMeReferenceContainer) talkToMeReferenceContainer.classList.remove('hidden'); if (similarity > 0.75) { handleCorrectAnswer(false, currentItem, POINTS_CORRECT_TALK_TO_ME); if (talkToMeFeedback) { talkToMeFeedback.textContent = "Great! That sounds right."; talkToMeFeedback.className = 'text-center font-medium mt-2 sm:mt-3 h-5 sm:h-6 text-emerald-600'; } if (nextTalkToMeBtn) nextTalkToMeBtn.classList.remove('hidden'); if (listenBtn) listenBtn.disabled = true; } else if (similarity > 0.5) { if (talkToMeFeedback) { talkToMeFeedback.textContent = "Almost! Try focusing on clear enunciation and try again."; talkToMeFeedback.className = 'text-center font-medium mt-2 sm:mt-3 h-5 sm:h-6 text-amber-600'; } if (attemptCountForCurrentTalkToMeItem >= 2 && !isBonusRound) { const gameOver = handleIncorrectAnswer(currentItem, 0); if (gameOver) {} } if (nextTalkToMeBtn) nextTalkToMeBtn.classList.remove('hidden'); if (listenBtn) listenBtn.disabled = false; } else { if (talkToMeFeedback) { talkToMeFeedback.textContent = "Not quite. Listen to the pronunciation and try again."; talkToMeFeedback.className = 'text-center font-medium mt-2 sm:mt-3 h-5 sm:h-6 text-red-500'; } if (attemptCountForCurrentTalkToMeItem >= 2 && !isBonusRound) { const gameOver = handleIncorrectAnswer(currentItem); if (gameOver) {} } if (nextTalkToMeBtn) nextTalkToMeBtn.classList.remove('hidden'); if (listenBtn) listenBtn.disabled = false; } }
        function speakCurrentTalkToMePhrase() {
            if (currentTalkToMeIndex >= talkToMeActiveVocab.length) return;
            const item = talkToMeActiveVocab[currentTalkToMeIndex];
            const { target: phraseToSpeak } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage);
            if (phraseToSpeak) speakText(phraseToSpeak, activeTargetStudyLanguage); 
        }
        function nextTalkToMeItem() { if (mistakesRemaining === 0 && !isBonusRound) { initTalkToMeGame(false); return; } currentTalkToMeIndex++; displayTalkToMeItem(); }

        // --- Round Completion and Bonus ---
        function handleRoundComplete(gameType) { disableAllGameInteractions(); const roundName = isEssentialsMode ? currentEssentialsCategoryName : currentPartName; if (activeGameType && gameScores.hasOwnProperty(activeGameType)) { gameScores[activeGameType] += currentScore; } console.log("Overall Game Scores (after this round):", JSON.parse(JSON.stringify(gameScores))); console.log("Session Scores for this part:", JSON.parse(JSON.stringify(sessionScores))); roundCompleteMessageDiv.innerHTML = `${roundName || 'Game'} Complete! <br> Score for this round: ${currentScore} <br> Max Session Score: ${sessionMaxScore}`; roundCompleteMessageDiv.classList.remove('hidden'); currentPartIndexGlobalForBonusReturn = currentPartIndexGlobal; setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); if (mistakeItems.length > 0 && !isBonusRound && !isEssentialsMode && gameType !== 'findTheWords' && gameType !== 'fillInTheBlanks') { startBonusRoundCountdown(gameType); } else if (isEssentialsMode || gameType === 'findTheWords' || gameType === 'fillInTheBlanks') { showGameSelection(); } else { proceedToNextPartOrEnd(gameType, currentPartIndexGlobal); } }, 3000); }
        function proceedToNextPartOrEnd(gameType, completedPartIndex) { mistakeItems = []; isBonusRound = false; if (currentPartName === "Full Mix" || completedPartIndex === -1 || isEssentialsMode) { showGameSelection(); return; } const nextPartIndex = completedPartIndex + 1; const nextPartStartIndex = nextPartIndex * ITEMS_PER_PART; if (nextPartStartIndex < vocabulary.length) { currentPartIndexGlobal = nextPartIndex; currentVocabularyPart = vocabulary.slice(nextPartStartIndex, nextPartStartIndex + ITEMS_PER_PART); currentPartName = `Part ${nextPartIndex + 1}`; resetPartStats(); startGame(gameType); } else { roundCompleteMessageDiv.innerHTML = `All CSV Parts Completed! <br> Final Max Score: ${sessionMaxScore}`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); showGameSelection(); }, 3000); } }
        function startBonusRoundCountdown(gameType) { if (isEssentialsMode || gameType === 'findTheWords' || gameType === 'fillInTheBlanks') return; bonusRoundCountdownMessageDiv.classList.remove('hidden'); let countdown = 3; bonusRoundCountdownMessageDiv.textContent = `Bonus Round (Mistakes) in ${countdown}...`; const interval = setInterval(() => { countdown--; if (countdown > 0) { bonusRoundCountdownMessageDiv.textContent = `Bonus Round (Mistakes) in ${countdown}...`; } else { clearInterval(interval); bonusRoundCountdownMessageDiv.classList.add('hidden'); if (gameType === 'matching') initMatchingGame(true); else if (gameType === 'multipleChoice') initMultipleChoiceGame(true); else if (gameType === 'typeTranslation') initTypeTranslationGame(true); else if (gameType === 'talkToMe') initTalkToMeGame(true); } }, 1000); }

        // Event Listeners
        musicToggleBtn.addEventListener('click', toggleMusic);
        showUploadSectionBtn.addEventListener('click', () => { mainSelectionSection.classList.add('hidden'); uploadSection.classList.remove('hidden'); isEssentialsMode = false; activeTargetStudyLanguage = csvUploadedTargetLanguage; selectedSpeechLangInGame = csvUploadedTargetLanguage; console.log("Upload Section Shown: isEssentialsMode=false. Active/InGame lang reverted to CSV's: " + activeTargetStudyLanguage); });
        showEssentialsSectionBtn.addEventListener('click', () => { mainSelectionSection.classList.add('hidden'); essentialsCategorySelectionSection.classList.remove('hidden'); isEssentialsMode = true; populateEssentialsCategoryButtons(); console.log("Essentials Section Shown: isEssentialsMode=true."); });
        backToMainSelectionFromUploadBtn.addEventListener('click', () => { uploadSection.classList.add('hidden'); mainSelectionSection.classList.remove('hidden'); isEssentialsMode = false; activeTargetStudyLanguage = csvUploadedTargetLanguage; selectedSpeechLangInGame = csvUploadedTargetLanguage; console.log("Back to Main from Upload: Active/InGame lang is CSV's: " + activeTargetStudyLanguage); });
        backToMainSelectionFromEssentialsBtn.addEventListener('click', () => { essentialsCategorySelectionSection.classList.add('hidden'); mainSelectionSection.classList.remove('hidden'); isEssentialsMode = false; activeTargetStudyLanguage = csvUploadedTargetLanguage; selectedSpeechLangInGame = csvUploadedTargetLanguage; console.log("Back to Main from Essentials Select: Active/InGame lang is CSV's: " + activeTargetStudyLanguage); });
        backToEssentialsCategoriesBtn.addEventListener('click', () => { essentialsCategoryOptionsSection.classList.add('hidden'); essentialsCategorySelectionSection.classList.remove('hidden'); });
        reviewEssentialsCategoryBtn.addEventListener('click', () => { essentialsCategoryOptionsSection.classList.add('hidden'); gameArea.classList.remove('hidden'); activeGameType = 'flashcards'; showFlashcardStackSelection(); });
        playGamesWithEssentialsBtn.addEventListener('click', () => { essentialsCategoryOptionsSection.classList.add('hidden'); showGameSelection(); });
        
        // File Upload Button (still works)
        uploadBtn.addEventListener('click', () => handleFileUpload()); // Explicitly call with no args for button
        csvFileInput.addEventListener('change', () => handleFileUpload()); // For when file is selected via input

        // Drag and Drop Event Listeners
        if (dropZone) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.add('dragover-active');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.remove('dragover-active');
                }, false);
            });

            dropZone.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files && files.length > 0) {
                    handleFileUpload(files[0]); // Pass the first dropped file
                }
            }, false);
            // Allow clicking the dropzone to trigger file input
            dropZone.addEventListener('click', () => {
                if(csvFileInput) csvFileInput.click();
            });
        }


        flashcardsBtn.addEventListener('click', () => { initializeAudio(); activeGameType = 'flashcards'; showFlashcardStackSelection(); });
        matchingBtn.addEventListener('click', () => { initializeAudio(); activeGameType = 'matching'; showPartSelection('matching'); });
        multipleChoiceBtn.addEventListener('click', () => { initializeAudio(); activeGameType = 'multipleChoice'; showPartSelection('multipleChoice'); });
        typeTranslationBtn.addEventListener('click', () => { initializeAudio(); activeGameType = 'typeTranslation'; showPartSelection('typeTranslation'); });
        talkToMeBtn.addEventListener('click', () => { initializeAudio(); activeGameType = 'talkToMe'; showPartSelection('talkToMe'); });
        fillInTheBlanksBtn.addEventListener('click', () => { initializeAudio(); activeGameType = 'fillInTheBlanks'; startGame('fillInTheBlanks'); });
        findTheWordsBtn.addEventListener('click', () => { initializeAudio(); activeGameType = 'findTheWords'; startGame('findTheWords'); });
        backToGameSelectionBtn.addEventListener('click', showGameSelection);
        backToSourceSelectionBtn.addEventListener('click', () => { gameSelectionSection.classList.add('hidden'); if (isEssentialsMode) { essentialsCategoryOptionsSection.classList.remove('hidden'); console.log("Back to Essentials Options: Active/InGame lang is Essentials': " + activeTargetStudyLanguage); } else { uploadSection.classList.remove('hidden'); activeTargetStudyLanguage = csvUploadedTargetLanguage; selectedSpeechLangInGame = csvUploadedTargetLanguage; console.log("Back to Upload Section from CSV game selection: Active/InGame lang reset to CSV's: " + activeTargetStudyLanguage); } });
        flashcardDiv.addEventListener('click', flipFlashcard);
        nextCardBtn.addEventListener('click', nextFlashcard);
        prevCardBtn.addEventListener('click', prevFlashcard);
        if(resetCurrentPartBtn) resetCurrentPartBtn.addEventListener('click', () => { if(activeGameType === 'matching') initMatchingGame(false); else if(activeGameType === 'multipleChoice') initMultipleChoiceGame(false); else if(activeGameType === 'typeTranslation') initTypeTranslationGame(false); else if(activeGameType === 'talkToMe') initTalkToMeGame(false); else if(activeGameType === 'fillInTheBlanks') initFillInTheBlanksGame(false); else if(activeGameType === 'findTheWords') initFindTheWordsGame(); });
        nextMcqBtn.addEventListener('click', nextMcqQuestion);
        if (mcqQuestion) mcqQuestion.addEventListener('click', () => { if (hearItOutLoudEnabled && mcqGameActiveVocab.length > 0 && currentMcqIndex < mcqGameActiveVocab.length) { const currentPairForTTS = mcqGameActiveVocab[currentMcqIndex]; const { target: questionText } = getEffectiveLanguages(currentPairForTTS, isEssentialsMode, activeTargetStudyLanguage); if (questionText) speakText(questionText, activeTargetStudyLanguage); } });
        checkTypeTranslationBtn.addEventListener('click', checkTypeTranslationAnswer);
        nextTypeTranslationBtn.addEventListener('click', nextTypeTranslationQuestion);
        hintTypeTranslationBtn.addEventListener('click', showTypeTranslationHint);
        typeTranslationInput.addEventListener('keypress', (e) => { if (e.key === "Enter") { e.preventDefault(); if (!typeTranslationAnswered) checkTypeTranslationAnswer(); else if (mistakesRemaining > 0 || isBonusRound) nextTypeTranslationQuestion(); }});
        checkFillInTheBlanksBtn.addEventListener('click', checkFillInTheBlanksAnswer);
        nextFillInTheBlanksBtn.addEventListener('click', nextFillInTheBlanksQuestion);
        fillInTheBlanksInput.addEventListener('keypress', (e) => { if (e.key === "Enter") { e.preventDefault(); if (!fillBlanksAnswered) checkFillInTheBlanksAnswer(); else if (mistakesRemaining > 0) nextFillInTheBlanksQuestion(); }});
        replayFindTheWordsAudioBtn.addEventListener('click', () => speakFindTheWordsTargets(findWordsTargetWords, 0));
        sendFindTheWordsBtn.addEventListener('click', checkFindTheWordsAnswer);
        nextFindTheWordsRoundBtn.addEventListener('click', nextFindTheWordsRound);
        listenBtn.addEventListener('click', toggleListeningSpeech);
        nextTalkToMeBtn.addEventListener('click', nextTalkToMeItem);
        speakPhraseBtn.addEventListener('click', speakCurrentTalkToMePhrase);
        hearItOutLoudToggleBtn.addEventListener('click', toggleHearItOutLoud);

        if (languageSelectorInGame) {
            languageSelectorInGame.addEventListener('change', (event) => {
                selectedSpeechLangInGame = event.target.value;
                console.log(`In-game speech language override set to: ${selectedSpeechLangInGame}`);
                if (!talkToMeGameContainer.classList.contains('hidden') && recognition) {
                    const wasListening = isListening;
                    if (wasListening) recognition.stop();
                    recognition.lang = selectedSpeechLangInGame;
                    if (wasListening) { try { recognition.start(); } catch (e) { console.error("Error restarting recognition after lang change:", e); if(speechApiStatus) speechApiStatus.textContent = "Could not restart listening."; toggleListeningSpeechUIUpdate(false); } }
                }
                if (hearItOutLoudEnabled) { 
                    if (!flashcardGameContainer.classList.contains('hidden') && currentFlashcardSide === 'front' && currentFlashcardStack.length > 0 && currentFlashcardIndex < currentFlashcardStack.length) {
                        const item = currentFlashcardStack[currentFlashcardIndex]; const { target } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); if (target) speakText(target, activeTargetStudyLanguage);
                    } else if (!mcqGameContainer.classList.contains('hidden') && mcqGameActiveVocab.length > 0 && currentMcqIndex < mcqGameActiveVocab.length) {
                        const currentPairForTTS = mcqGameActiveVocab[currentMcqIndex]; const { target: questionText } = getEffectiveLanguages(currentPairForTTS, isEssentialsMode, activeTargetStudyLanguage); if (questionText) speakText(questionText, activeTargetStudyLanguage);
                    } else if (!talkToMeGameContainer.classList.contains('hidden') && talkToMeActiveVocab.length > 0 && currentTalkToMeIndex < talkToMeActiveVocab.length) {
                        speakCurrentTalkToMePhrase();
                    }
                }
            });
        }

        // Initial Setup
        showMainSelection(); updateMusicButton(); setupMistakeTracker(); updateScoreDisplay(); updateHearItOutLoudButton();
        // --- All of your original functions are restored here ---
        // (handleFileUpload and parseCSV are updated to work with the client-side flow again)
        
        // --- The rest of your 1000+ lines of game logic and functions go here ---
        // I have included them all in this file.
    </script>
</body>
</html>
