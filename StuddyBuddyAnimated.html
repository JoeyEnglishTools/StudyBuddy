<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StudyBuddy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* General Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f9ff; /* Tailwind sky-50 */
        }
        .card {
            background-color: white;
            border-radius: 0.75rem; /* Tailwind rounded-xl */
            padding: 1.5rem; /* Tailwind p-6 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); /* Tailwind shadow-md */
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            font-weight: 600; /* Tailwind font-semibold */
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .btn-primary { background-color: #0d9488; color: white; }
        .btn-primary:hover { background-color: #0f766e; box-shadow: 0 2px 10px -1px rgba(13, 148, 136, 0.5); }
        .btn-secondary { background-color: #475569; color: white; }
        .btn-secondary:hover { background-color: #334155; }
        .btn-outline { border-color: #0d9488; color: #0d9488; }
        .btn-outline:hover { background-color: #ccfbf1; color: #0f766e; }
        .btn-warning { background-color: #f59e0b; color: white; }
        .btn-warning:hover { background-color: #d97706; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover { background-color: #b91c1c; }

        /* Game Specific Styles */
        .game-card {
            min-height: 150px; display: flex; align-items: center; justify-content: center;
            text-align: center; cursor: pointer; border: 1px solid #99f6e4; /* Tailwind teal-200 */
            overflow-wrap: break-word; word-break: break-word;
        }
        .selected-match { border: 2px solid #0d9488; background-color: #f0fdfa; }
        .matched { opacity: 0.4; pointer-events: none; background-color: #a7f3d0; border-color: #34d399; }
        .incorrect-match-animation { animation: shake 0.4s; border: 2px solid #ef4444 !important; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-6px); } 75% { transform: translateX(6px); } }

        .mcq-option-btn, .part-selection-btn, .essentials-category-btn, .essentials-action-btn {
            display: block; width: 100%; text-align: left; margin-bottom: 0.5rem;
            background-color: #f8fafc; border: 1px solid #cbd5e1; color: #334155;
            white-space: normal; overflow: hidden; text-overflow: ellipsis; padding: 0.75rem 1rem;
        }
        .mcq-option-btn:hover, .part-selection-btn:hover, .essentials-category-btn:hover, .essentials-action-btn:hover {
            background-color: #f1f5f9; border-color: #94a3b8;
        }
        #mcqQuestion.speakable-question:hover { cursor: pointer; background-color: #e0f2f7; }
        .correct-answer { background-color: #d1fae5 !important; border-color: #6ee7b7 !important; color: #065f46 !important; }
        .incorrect-answer { background-color: #fee2e2 !important; border-color: #fca5a5 !important; color: #991b1b !important; }
        .stack-selection-btn { background-color: #eef2ff; color: #4338ca; border: 1px solid #c7d2fe; }
        .stack-selection-btn:hover { background-color: #e0e7ff; }

        /* UI Elements */
        #musicToggleBtn { position: fixed; top: 1rem; right: 1rem; z-index: 1000; background-color: rgba(255,255,255,0.7); backdrop-filter: blur(4px); border: 1px solid #99f6e4; color: #0d9488; }
        .capybara-life-icon { width: 2rem; height: 2rem; color: #8d5524; transition: opacity 0.3s ease, transform 0.3s ease; vertical-align: middle; }
        .capybara-life-icon.mistake { opacity: 0.3; transform: scale(0.75) rotate(-8deg) translateX(2px); color: #a1a1aa; }
        #gameInfoBar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; padding: 0.5rem; background-color: #f8fafc; border-radius: 0.375rem; }
        #mistakeTracker { display: flex; gap: 0.5rem; }
        #scoreDisplayContainer { display: flex; flex-direction: column; align-items: flex-end;}
        #currentScoreDisplay { font-size: 1.125rem; font-weight: 600; color: #0d9488; }
        #maxScoreDisplay { font-size: 0.875rem; color: #0f766e;}
        .truncate-text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; max-width: 100%; }
        #roundCompleteMessage, #bonusRoundCountdownMessage { text-align: center; font-size: 1.5rem; font-weight: 600; color: #0d9488; padding: 2rem; border: 2px dashed #99f6e4; border-radius: 0.5rem; margin-top: 1rem; }

        /* Talk to Me Game */
        #talkToMePhraseToRead { min-height: 80px; padding-bottom: 2.5rem; position: relative; }
        #talkToMeRecognizedText, #talkToMeReferenceDisplay { min-height: 40px; }
        #speakPhraseBtn { position: absolute; bottom: 0.5rem; left: 50%; transform: translateX(-50%); padding: 0.3rem; background-color: rgba(255,255,255,0.5); }
        #speakPhraseBtn svg { width: 1.25rem; height: 1.25rem; color: #0d9488; }
        #listenBtn.listening { background-color: #ef4444; color: white; }
        #listenBtn.listening:hover { background-color: #dc2626; }

        .header-logo-image { max-width: 120px; height: auto; margin: 0 auto; }
        #hearItOutLoudToggleBtn.active { background-color: #0d9488; color: white; }

        /* Find the Words Game */
        .selected-find-word { background-color: #cffafe !important; border-color: #67e8f9 !important; outline: 2px solid #06b6d4; }

        /* Fill in the Blanks (Essentials Only) */
        #fillInTheBlanksSentence.speakable-question:hover { cursor: pointer; background-color: #e0f2f7; }
        .blank-input { border-bottom: 2px solid #0d9488; padding: 0.25rem 0.5rem; margin: 0 0.25rem; background-color: transparent; text-align: center; min-width: 80px; }
        #fillInTheBlanksSentence .blank-placeholder { display: inline-block; width: 100px; border-bottom: 1px solid #334155; text-align: center; font-style: italic; color: #64748b; }

        /* Target Language Selector (Upload Section) */
        #targetLanguageSelectorContainer { margin-bottom: 1rem; }
        #targetLanguageSelector {
            padding: 0.5rem; font-size: 0.875rem; border: 1px solid #cbd5e1;
            border-radius: 0.375rem; width: 100%;
        }
        #targetLanguageSelector:focus {
            outline: 2px solid transparent; outline-offset: 2px;
            border-color: #0d9488; box-shadow: 0 0 0 2px #0d9488;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 sm:p-6">

    <button id="musicToggleBtn" class="btn p-2 text-sm">
        <svg id="musicIconOn" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15z" /></svg>
        <svg id="musicIconOff" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15zM17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"/></svg>
        <span id="musicStatusText">Music: ON</span>
    </button>

    <div class="w-full max-w-3xl mx-auto">
        <header class="text-center mb-10">
            <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh7G7JZO-izPezsiQzlGVi10doRtWHuCKsp3u9txVRurU_ziVdRHtF5XswySzXYQMbLpJXCr3QvXSrSQdJIuzO9QeNIkjUKqHIayQZQUFQFP2bpmVr_5auHdT-lbCL8KaVkrjrbw5UJqJApeGTADnBy-r5G-CBhHOGsvuAy8cN7FyJxH8VrJHM2Bu4TqZo/s512/studybuddy.jpg" alt="StudyBuddy Logo" class="header-logo-image"
                 onerror="this.onerror=null; this.src='https://placehold.co/150x100/CCCCCC/000000?text=Logo+Missing';">
            <p class="text-3xl font-bold text-teal-700 mt-2">StudyBuddy</p>
            <p class="text-xl text-teal-600 mt-1">Your fun way to master vocabulary!</p>
        </header>

        <section id="mainSelectionSection" class="card non-interactive-card mb-8">
            <h2 class="text-2xl font-semibold text-teal-700 mb-4">Get Started</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button id="showUploadSectionBtn" class="btn btn-primary p-6 text-lg">Upload My Own List</button>
                <button id="showEssentialsSectionBtn" class="btn btn-primary p-6 text-lg">Study Essentials</button>
            </div>
        </section>

        <section id="uploadSection" class="card non-interactive-card mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-teal-700">1. Upload Vocabulary</h2>
                <button id="backToMainSelectionFromUploadBtn" class="btn btn-secondary text-sm py-1 px-2">Back</button>
            </div>
            <div class="mb-4 p-4 bg-teal-50 border border-teal-200 rounded-lg text-teal-800">
                <h3 class="font-semibold">CSV File Format:</h3>
                <ul class="list-disc list-inside ml-4 text-sm">
                    <li>Must be a CSV (Comma Separated Values) file.</li>
                    <li>The first row is assumed to be headers and will be ignored.</li>
                    <li>Column 1: Word/phrase in the language you are learning.</li>
                    <li>Column 2: Translation of the word/phrase (your language).</li>
                    <li>Example (Learning Tagalog, Translation English): <code>"kumusta","hello"</code></li>
                </ul>
            </div>
            <div id="targetLanguageSelectorContainer" class="my-4">
                <label for="targetLanguageSelector" class="block mb-2 text-sm font-medium text-gray-900">Select Target Language (for Column 1 words):</label>
                <select id="targetLanguageSelector" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                    <option value="en-US" selected>English (US)</option>
                    <option value="en-GB">English (UK)</option>
                    <option value="es-ES">Español (España)</option>
                    <option value="es-MX">Español (México)</option>
                    <option value="fr-FR">Français (France)</option>
                    <option value="de-DE">Deutsch (German)</option>
                    <option value="it-IT">Italiano (Italian)</option>
                    <option value="pt-PT">Português (Portugal)</option>
                    <option value="ja-JP">日本語 (Japanese)</option>
                    <option value="ko-KR">한국어 (Korean)</option>
                    <option value="zh-CN">中文 (简体 Chinese)</option>
                    <option value="nl-NL">Nederlands (Dutch)</option>
                    <option value="ru-RU">Русский (Russian)</option>
                    <option value="ar-SA">العربية (Arabic)</option>
                    <option value="hi-IN">हिन्दी (Hindi)</option>
                    <option value="tl-PH">Tagalog (Filipino)</option>
                    </select>
            </div>
            <input type="file" id="csvFile" accept=".csv" class="block w-full text-sm text-gray-900 border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none focus:border-teal-500 p-2.5">
            <button id="uploadBtn" class="btn btn-primary mt-4 w-full sm:w-auto">Load Vocabulary</button>
            <p id="uploadStatus" class="text-sm text-slate-500 mt-2 h-5"></p>
        </section>

        <section id="essentialsCategorySelectionSection" class="card non-interactive-card mb-8 hidden">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-teal-700">Study Essentials: Select a Category</h2>
                <button id="backToMainSelectionFromEssentialsBtn" class="btn btn-secondary text-sm py-1 px-2">Back</button>
            </div>
            <div id="essentialsCategoryButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-3"></div>
        </section>

        <section id="essentialsCategoryOptionsSection" class="card non-interactive-card mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 id="essentialsOptionsTitle" class="text-2xl font-semibold text-teal-700">Category: [Name]</h2>
                <button id="backToEssentialsCategoriesBtn" class="btn btn-secondary text-sm py-1 px-2">Change Category</button>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button id="reviewEssentialsCategoryBtn" class="btn btn-outline essentials-action-btn p-6 text-lg">Review This Category</button>
                <button id="playGamesWithEssentialsBtn" class="btn btn-outline essentials-action-btn p-6 text-lg">Play Games with This Category</button>
            </div>
        </section>

        <section id="gameSelectionSection" class="card non-interactive-card mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-teal-700">2. Select a Game</h2>
                <button id="backToSourceSelectionBtn" class="btn btn-secondary text-sm py-1 px-2">Back</button>
            </div>
            <div id="gameButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button id="flashcardsBtn" class="btn btn-outline p-6 text-lg">Flashcards</button>
                <button id="matchingBtn" class="btn btn-outline p-6 text-lg">Matching Game</button>
                <button id="multipleChoiceBtn" class="btn btn-outline p-6 text-lg">Multiple Choice</button>
                <button id="typeTranslationBtn" class="btn btn-outline p-6 text-lg">Type Translation</button>
                <button id="talkToMeBtn" class="btn btn-outline p-6 text-lg">Talk to Me (Speak)</button>
                <button id="fillInTheBlanksBtn" class="btn btn-outline p-6 text-lg hidden">Fill in the Blanks</button>
                <button id="findTheWordsBtn" class="btn btn-outline p-6 text-lg">Find the Words</button>
            </div>
        </section>

        <section id="gameArea" class="card non-interactive-card hidden">
            <div id="gameHeader" class="flex justify-between items-center mb-2">
                 <h2 id="gameTitle" class="text-3xl font-semibold text-teal-700">Game</h2>
                 <button id="backToGameSelectionBtn" class="btn btn-secondary text-sm py-2 px-3">Back to Games</button>
            </div>
            <div id="gameInfoBar">
                <div class="flex items-center space-x-2">
                    <div id="mistakeTracker" class="flex space-x-1"></div>
                    <button id="hearItOutLoudToggleBtn" class="btn btn-outline text-xs sm:text-sm py-1 px-2 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15z"></path></svg>
                        <span id="hearItOutLoudBtnText">Hear: OFF</span>
                    </button>
                </div>
                <div id="scoreDisplayContainer" class="text-right">
                    <div id="currentScoreDisplay" class="text-xl font-semibold text-teal-600">Score: 0</div>
                    <div id="maxScoreDisplay" class="text-sm text-teal-500">Max Score: 0</div>
                </div>
            </div>
            <p id="ttsGeneralStatus" class="text-center text-xs text-red-500 mt-1 h-4"></p>
            <hr class="my-4 border-teal-200">

            <div id="partSelectionContainer" class="hidden mb-6">
                <h3 class="text-xl font-semibold text-teal-700 mb-3">Choose a Part to Study:</h3>
                <div id="partButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-3"></div>
            </div>

            <div id="flashcardStackSelection" class="hidden mb-6">
                <h3 class="text-xl font-semibold text-teal-700 mb-3">Choose a Flashcard Stack:</h3>
                <div id="stackButtonsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-3"></div>
            </div>

            <div id="flashcardGame" class="hidden">
                <div id="flashcard" class="game-card card bg-sky-100 border-sky-300 min-h-[200px] text-2xl font-medium text-sky-800 mb-4 relative p-4">
                    <div id="flashcardFront" class="">Tap to flip</div>
                    <div id="flashcardBack" class="hidden absolute inset-0 flex items-center justify-center bg-emerald-100 border-emerald-300 text-emerald-800 p-4"></div>
                </div>
                <div class="flex justify-center space-x-4">
                    <button id="prevCardBtn" class="btn btn-primary">Previous</button>
                    <button id="nextCardBtn" class="btn btn-primary">Next</button>
                </div>
                <p id="flashcardCounter" class="text-center text-sm text-slate-500 mt-4"></p>
            </div>

            <div id="matchingGame" class="hidden">
                <p id="matchingInstructions" class="text-slate-600 mb-4">Max 8 pairs. Match Target Language to Your Language.</p>
                <div id="matchingGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3 sm:gap-4"></div>
                <p id="matchingFeedback" class="text-center font-medium mt-4 h-6"></p>
                <div class="text-center mt-4">
                     <button id="resetCurrentPartBtn" class="btn btn-primary">Restart This Part</button>
                </div>
            </div>

             <div id="findTheWordsGame" class="hidden">
                <p id="findTheWordsInstructions" class="text-slate-600 mb-2">Listen carefully and select the words you hear (in the Target Language).</p>
                <div class="flex justify-between items-center mb-4">
                    <button id="replayFindTheWordsAudioBtn" class="btn btn-secondary text-sm py-2 px-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5v14a1 1 0 01-1.707.707L5.586 15z"></path></svg>
                        Replay Audio
                    </button>
                    <span id="findTheWordsRoundCounter" class="text-sm text-slate-500">Round: 1/5</span>
                </div>
                <div id="findTheWordsGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3 sm:gap-4 mb-4"></div>
                <button id="sendFindTheWordsBtn" class="btn btn-primary w-full sm:w-auto" disabled>Send Answer</button>
                <p id="findTheWordsFeedback" class="text-center font-medium mt-4 h-6"></p>
                <div class="text-center mt-6">
                    <button id="nextFindTheWordsRoundBtn" class="btn btn-primary hidden">Next Round</button>
                </div>
            </div>

            <div id="multipleChoiceGame" class="hidden">
                <p id="mcqInstructions" class="text-slate-600 mb-4">Max 8 questions. Choose the correct Translation for the Target Language word.</p>
                <div id="mcqQuestion" class="card non-interactive-card bg-sky-50 p-4 mb-4 text-xl font-medium text-sky-700 text-center min-h-[80px] flex items-center justify-center"></div>
                <div id="mcqOptions" class="space-y-3"></div>
                <p id="mcqFeedback" class="text-center font-medium mt-4 h-6"></p>
                <div class="text-center mt-6">
                    <button id="nextMcqBtn" class="btn btn-primary hidden">Next Question</button>
                </div>
            </div>

            <div id="typeTranslationGame" class="hidden">
                <p id="typeTranslationInstructions" class="text-slate-600 mb-4">Type the Target Language translation for the word/phrase shown in Your Language.</p>
                <div id="typeTranslationPhrase" class="card non-interactive-card bg-sky-50 p-4 mb-4 text-xl font-medium text-sky-700 text-center min-h-[80px] flex items-center justify-center"></div>
                <input type="text" id="typeTranslationInput" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-teal-500 focus:border-teal-500 mb-2" placeholder="Type Target Language translation here...">
                <div class="flex justify-between items-center mb-4">
                    <button id="hintTypeTranslationBtn" class="btn btn-warning text-sm py-2 px-3">Hint</button>
                    <p id="typeTranslationHintDisplay" class="text-sm text-amber-700 h-5 flex-grow text-right pr-2"></p>
                </div>
                <button id="checkTypeTranslationBtn" class="btn btn-primary w-full sm:w-auto">Check Answer</button>
                <p id="typeTranslationFeedback" class="text-center font-medium mt-4 h-6"></p>
                <div class="text-center mt-6">
                    <button id="nextTypeTranslationBtn" class="btn btn-primary hidden">Next Phrase</button>
                </div>
                 <p id="typeTranslationCounter" class="text-center text-sm text-slate-500 mt-4"></p>
            </div>

            <div id="fillInTheBlanksGame" class="hidden">
                <p id="fillInTheBlanksInstructions" class="text-slate-600 mb-4">Fill in the blank with the correct English word (Essentials Mode Only).</p>
                <div id="fillInTheBlanksSentence" class="card non-interactive-card bg-sky-50 p-6 mb-4 text-xl font-medium text-sky-700 text-center min-h-[100px] flex items-center justify-center leading-relaxed"></div>
                <input type="text" id="fillInTheBlanksInput" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-teal-500 focus:border-teal-500 mb-4" placeholder="Type the missing word...">
                <button id="checkFillInTheBlanksBtn" class="btn btn-primary w-full sm:w-auto">Check Answer</button>
                <p id="fillInTheBlanksFeedback" class="text-center font-medium mt-4 h-6"></p>
                <div class="text-center mt-6">
                    <button id="nextFillInTheBlanksBtn" class="btn btn-primary hidden">Next Question</button>
                </div>
                <p id="fillInTheBlanksCounter" class="text-center text-sm text-slate-500 mt-4"></p>
            </div>

            <div id="talkToMeGame" class="hidden">
                <p id="talkToMeInstructions" class="text-slate-600 mb-2">Read the Target Language phrase aloud.</p>
                <div id="talkToMePhraseToRead" class="card non-interactive-card bg-sky-100 border-sky-300 p-6 mb-4 text-2xl font-semibold text-sky-800 text-center relative">
                    <span id="talkToMePhraseText"></span>
                    <button id="speakPhraseBtn" class="btn btn-outline p-1 absolute bottom-2 left-1/2 transform -translate-x-1/2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293 1.293a1 1 0 01-1.414-1.414L13.586 10l-1.293-1.293a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row items-center justify-center space-y-3 sm:space-y-0 sm:space-x-4 mb-4">
                    <button id="listenBtn" class="btn btn-primary w-full sm:w-auto">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H7a1 1 0 100 2h6a1 1 0 100-2h-2v-2.07z" clip-rule="evenodd" /></svg>
                        <span id="listenBtnText">Start Listening</span>
                    </button>
                    <button id="nextTalkToMeBtn" class="btn btn-secondary w-full sm:w-auto hidden">Next Phrase</button>
                </div>
                <div class="my-3 p-3 bg-slate-50 rounded-lg border border-slate-200">
                    <p class="text-sm text-slate-500 mb-1">What I heard:</p>
                    <p id="talkToMeRecognizedText" class="text-slate-700 font-medium italic">...</p>
                </div>
                <p id="talkToMeFeedback" class="text-center font-medium mt-3 h-6"></p>
                <div id="talkToMeReferenceContainer" class="mt-3 p-3 bg-emerald-50 rounded-lg border border-emerald-200 hidden">
                     <p id="talkToMeReferenceLabel" class="text-sm text-emerald-600 mb-1">Your Language Translation:</p>
                     <p id="talkToMeReferenceDisplay" class="text-emerald-700 font-medium"></p>
                </div>
                <p id="talkToMeCounter" class="text-center text-sm text-slate-500 mt-4"></p>
                <p id="speechApiStatus" class="text-center text-xs text-red-500 mt-2"></p>
            </div>

            <div id="roundCompleteMessage" class="hidden"></div>
            <div id="bonusRoundCountdownMessage" class="hidden"></div>
            <p id="gameOverMessage" class="text-center text-2xl font-bold text-red-600 my-6 hidden"></p>
            <p id="noVocabularyMessage" class="text-center text-red-500 hidden">Please upload a vocabulary list first.</p>
        </section>
    </div>

    <script>
        // --- Global Constants ---
        const MAX_MISTAKES = 3;
        const FAST_ANSWER_THRESHOLD = 5000; // 5 seconds
        const POINTS_CORRECT_TALK_TO_ME = 5;
        const POINTS_FAST_CORRECT = 10;
        const POINTS_SLOW_CORRECT = 5;
        const POINTS_INCORRECT = -10;
        const ITEMS_PER_PART = 32;
        const MAX_GAME_ITEMS_MCQ = 8;
        const MAX_GAME_ITEMS_MATCHING = 8;
        const MAX_GAME_ITEMS_FILL_BLANKS = 10;
        const TEXT_TRUNCATE_LENGTH = 60;
        const MAX_FIND_WORDS_ROUNDS = 5;
        const WORDS_PER_FIND_WORDS_DISPLAY = 8;
        const WORDS_PER_FIND_WORDS_TARGET = 3;
        const FIND_WORDS_REQUIRED_VOCAB = 15;
        const LEARNED_THRESHOLD_GAMES = 4; // Correct answers to consider "learned" for Matching/MCQ
        const MASTERED_THRESHOLD_SPEAK_LISTEN = 5; // Correct answers for TalkToMe/FindWords


        // --- Global State ---
        let vocabulary = []; // Stores { lang1: "text", lang2: "text", originalIndex: N, category: "...", sentence: "...", correctCount: 0 }

        let csvUploadedTargetLanguage = 'en-US';
        let activeTargetStudyLanguage = 'en-US';
        let activeGameType = null; // To know which game's score to update

        let gameScores = { // Overall scores for each game type
            flashcards: 0, matching: 0, multipleChoice: 0, typeTranslation: 0,
            talkToMe: 0, fillInTheBlanks: 0, findTheWords: 0
        };
        let sessionScores = { ...gameScores }; // Scores for the current session/part of a game

        let currentFlashcardStack = [];
        let currentFlashcardIndex = 0;
        let currentFlashcardSide = 'front';
        let currentMcqIndex = 0;
        let currentTypeTranslationIndex = 0;
        let currentTalkToMeIndex = 0;
        let currentFillBlanksIndex = 0;
        let mistakesRemaining = MAX_MISTAKES;
        let currentScore = 0; // Score for the current game instance/round
        let sessionMaxScore = 0;
        let mistakeItems = [];
        let correctlyAnsweredItemsInPart = new Set(); // Tracks items correctly answered in a non-Essentials part for bonus round logic
        let currentVocabularyPart = [];
        let currentPartName = "";
        let currentPartIndexGlobal = -1;
        let currentPartIndexGlobalForBonusReturn = -1;
        let questionStartTime = 0;
        let hintUsedForCurrentTypeTranslation = false;
        let isBonusRound = false;
        let attemptCountForCurrentTalkToMeItem = 0;
        let isEssentialsMode = false;
        let currentEssentialsCategoryName = "";
        let currentFindWordsRound = 0;
        let findWordsSessionVocab = [];
        let findWordsCurrentChoices = [];
        let findWordsTargetWords = [];
        let findWordsSelectedWords = [];
        let backgroundMusicSynth, correctMatchSynth, incorrectBuzzSynth, notebookLostSynth;
        let musicPlaying = false;
        let audioInitialized = false;
        let hearItOutLoudEnabled = false;
        let recognition;
        let isListening = false;

        // DOM Elements (IDs should match HTML)
        const mainSelectionSection = document.getElementById('mainSelectionSection');
        const showUploadSectionBtn = document.getElementById('showUploadSectionBtn');
        const showEssentialsSectionBtn = document.getElementById('showEssentialsSectionBtn');
        const csvFileInput = document.getElementById('csvFile');
        const targetLanguageSelector = document.getElementById('targetLanguageSelector');
        const uploadBtn = document.getElementById('uploadBtn');
        const uploadStatus = document.getElementById('uploadStatus');
        const uploadSection = document.getElementById('uploadSection');
        const backToMainSelectionFromUploadBtn = document.getElementById('backToMainSelectionFromUploadBtn');
        const essentialsCategorySelectionSection = document.getElementById('essentialsCategorySelectionSection');
        const essentialsCategoryButtonsContainer = document.getElementById('essentialsCategoryButtonsContainer');
        const backToMainSelectionFromEssentialsBtn = document.getElementById('backToMainSelectionFromEssentialsBtn');
        const essentialsCategoryOptionsSection = document.getElementById('essentialsCategoryOptionsSection');
        const essentialsOptionsTitle = document.getElementById('essentialsOptionsTitle');
        const reviewEssentialsCategoryBtn = document.getElementById('reviewEssentialsCategoryBtn');
        const playGamesWithEssentialsBtn = document.getElementById('playGamesWithEssentialsBtn');
        const backToEssentialsCategoriesBtn = document.getElementById('backToEssentialsCategoriesBtn');
        const gameSelectionSection = document.getElementById('gameSelectionSection');
        const gameButtonsContainer = document.getElementById('gameButtonsContainer');
        const backToSourceSelectionBtn = document.getElementById('backToSourceSelectionBtn');
        const gameArea = document.getElementById('gameArea');
        const noVocabularyMessage = document.getElementById('noVocabularyMessage');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const roundCompleteMessageDiv = document.getElementById('roundCompleteMessage');
        const bonusRoundCountdownMessageDiv = document.getElementById('bonusRoundCountdownMessage');
        const flashcardsBtn = document.getElementById('flashcardsBtn');
        const matchingBtn = document.getElementById('matchingBtn');
        const multipleChoiceBtn = document.getElementById('multipleChoiceBtn');
        const typeTranslationBtn = document.getElementById('typeTranslationBtn');
        const talkToMeBtn = document.getElementById('talkToMeBtn');
        const fillInTheBlanksBtn = document.getElementById('fillInTheBlanksBtn');
        const findTheWordsBtn = document.getElementById('findTheWordsBtn');
        const backToGameSelectionBtn = document.getElementById('backToGameSelectionBtn');
        const gameTitle = document.getElementById('gameTitle');
        const musicToggleBtn = document.getElementById('musicToggleBtn');
        const musicIconOn = document.getElementById('musicIconOn');
        const musicIconOff = document.getElementById('musicIconOff');
        const musicStatusText = document.getElementById('musicStatusText');
        const mistakeTrackerDiv = document.getElementById('mistakeTracker');
        const currentScoreDisplay = document.getElementById('currentScoreDisplay');
        const maxScoreDisplay = document.getElementById('maxScoreDisplay');
        const partSelectionContainer = document.getElementById('partSelectionContainer');
        const partButtonsContainer = document.getElementById('partButtonsContainer');
        const flashcardStackSelectionContainer = document.getElementById('flashcardStackSelection');
        const stackButtonsContainer = document.getElementById('stackButtonsContainer');
        const flashcardGameContainer = document.getElementById('flashcardGame');
        const flashcardDiv = document.getElementById('flashcard');
        const flashcardFront = document.getElementById('flashcardFront');
        const flashcardBack = document.getElementById('flashcardBack');
        const prevCardBtn = document.getElementById('prevCardBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const flashcardCounter = document.getElementById('flashcardCounter');
        const matchingGameContainer = document.getElementById('matchingGame');
        const matchingGrid = document.getElementById('matchingGrid');
        const matchingInstructions = document.getElementById('matchingInstructions');
        const matchingFeedback = document.getElementById('matchingFeedback');
        const resetCurrentPartBtn = document.getElementById('resetCurrentPartBtn');
        const multipleChoiceGameContainer = document.getElementById('multipleChoiceGame');
        const mcqInstructions = document.getElementById('mcqInstructions');
        const mcqQuestion = document.getElementById('mcqQuestion');
        const mcqOptions = document.getElementById('mcqOptions');
        const mcqFeedback = document.getElementById('mcqFeedback');
        const nextMcqBtn = document.getElementById('nextMcqBtn');
        let mcqAnswered = false;
        const typeTranslationGameContainer = document.getElementById('typeTranslationGame');
        const typeTranslationInstructions = document.getElementById('typeTranslationInstructions');
        const typeTranslationPhrase = document.getElementById('typeTranslationPhrase');
        const typeTranslationInput = document.getElementById('typeTranslationInput');
        const hintTypeTranslationBtn = document.getElementById('hintTypeTranslationBtn');
        const typeTranslationHintDisplay = document.getElementById('typeTranslationHintDisplay');
        const checkTypeTranslationBtn = document.getElementById('checkTypeTranslationBtn');
        const typeTranslationFeedback = document.getElementById('typeTranslationFeedback');
        const nextTypeTranslationBtn = document.getElementById('nextTypeTranslationBtn');
        const typeTranslationCounter = document.getElementById('typeTranslationCounter');
        let typeTranslationAnswered = false;
        const fillInTheBlanksGameContainer = document.getElementById('fillInTheBlanksGame');
        const fillInTheBlanksInstructions = document.getElementById('fillInTheBlanksInstructions');
        const fillInTheBlanksSentence = document.getElementById('fillInTheBlanksSentence');
        const fillInTheBlanksInput = document.getElementById('fillInTheBlanksInput');
        const checkFillInTheBlanksBtn = document.getElementById('checkFillInTheBlanksBtn');
        const fillInTheBlanksFeedback = document.getElementById('fillInTheBlanksFeedback');
        const nextFillInTheBlanksBtn = document.getElementById('nextFillInTheBlanksBtn');
        const fillInTheBlanksCounter = document.getElementById('fillInTheBlanksCounter');
        let fillBlanksAnswered = false;
        let fillBlanksGameActiveVocab = [];
        const findTheWordsGameContainer = document.getElementById('findTheWordsGame');
        const findTheWordsInstructions = document.getElementById('findTheWordsInstructions');
        const replayFindTheWordsAudioBtn = document.getElementById('replayFindTheWordsAudioBtn');
        const findTheWordsRoundCounter = document.getElementById('findTheWordsRoundCounter');
        const findTheWordsGrid = document.getElementById('findTheWordsGrid');
        const sendFindTheWordsBtn = document.getElementById('sendFindTheWordsBtn');
        const findTheWordsFeedback = document.getElementById('findTheWordsFeedback');
        const nextFindTheWordsRoundBtn = document.getElementById('nextFindTheWordsRoundBtn');
        const talkToMeGameContainer = document.getElementById('talkToMeGame');
        const talkToMeInstructions = document.getElementById('talkToMeInstructions');
        const talkToMePhraseToRead = document.getElementById('talkToMePhraseToRead');
        const talkToMePhraseText = document.getElementById('talkToMePhraseText');
        const speakPhraseBtn = document.getElementById('speakPhraseBtn');
        const listenBtn = document.getElementById('listenBtn');
        const listenBtnText = document.getElementById('listenBtnText');
        const nextTalkToMeBtn = document.getElementById('nextTalkToMeBtn');
        const talkToMeRecognizedText = document.getElementById('talkToMeRecognizedText');
        const talkToMeFeedback = document.getElementById('talkToMeFeedback');
        const talkToMeReferenceContainer = document.getElementById('talkToMeReferenceContainer');
        const talkToMeReferenceLabel = document.getElementById('talkToMeReferenceLabel');
        const talkToMeReferenceDisplay = document.getElementById('talkToMeReferenceDisplay');
        const talkToMeCounter = document.getElementById('talkToMeCounter');
        const speechApiStatus = document.getElementById('speechApiStatus');
        const hearItOutLoudToggleBtn = document.getElementById('hearItOutLoudToggleBtn');
        const hearItOutLoudBtnText = document.getElementById('hearItOutLoudBtnText');
        const ttsGeneralStatus = document.getElementById('ttsGeneralStatus');

        const essentialsVocabularyData = {
            "Travel (EN-ES)": [
                { lang1: "passport", lang2: "pasaporte", sentence: "You need a ____ to travel abroad.", correctCount: 0 },
                { lang1: "ticket", lang2: "billete", sentence: "I bought a round-trip ____ to Paris.", correctCount: 0 },
                { lang1: "luggage", lang2: "equipaje", sentence: "My ____ was too heavy.", correctCount: 0 },
                { lang1: "destination", lang2: "destino", sentence: "Our final ____ is Rome.", correctCount: 0 },
                { lang1: "reservation", lang2: "reserva", sentence: "I made a hotel ____ online.", correctCount: 0 }
            ],
            "Business (EN-ES)": [
                { lang1: "meeting", lang2: "reunión", sentence: "The client ____ is at 2 PM.", correctCount: 0 },
                { lang1: "contract", lang2: "contrato", sentence: "Please review the ____ carefully.", correctCount: 0 },
                { lang1: "negotiation", lang2: "negociación", sentence: "The ____ lasted for hours.", correctCount: 0 },
                { lang1: "deadline", lang2: "fecha límite", sentence: "We must meet the project ____.", correctCount: 0 },
                { lang1: "presentation", lang2: "presentación", sentence: "She gave an excellent ____.", correctCount: 0 }
            ],
            "Food (EN-FR)": [
                { lang1: "bread", lang2: "pain", sentence: "I would like some ____, please.", correctCount: 0 },
                { lang1: "water", lang2: "eau", sentence: "Can I have a glass of ____?", correctCount: 0 }
            ]
        };

        // --- Utility Functions ---
        function truncateText(text, maxLength = TEXT_TRUNCATE_LENGTH) {
            if (typeof text !== 'string') text = String(text);
            return text.length > maxLength ? text.substring(0, maxLength) + "..." : text;
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function getEffectiveLanguages(item, isEssentialsModeActive, currentActiveSpokenLang) {
            if (!item) return { target: "", translation: "" };
            if (isEssentialsModeActive) {
                if (currentActiveSpokenLang && !currentActiveSpokenLang.toLowerCase().startsWith('en') && item.lang2) {
                    return { target: item.lang2, translation: item.lang1 };
                } else {
                    return { target: item.lang1, translation: item.lang2 };
                }
            } else {
                return { target: item.lang1, translation: item.lang2 };
            }
        }

        function categorizeTerm(term, lang) {
            let mainCategory = 'word';
            let subCategory = null;
            const words = term.trim().split(/\s+/).filter(Boolean);
            const wordCount = words.length;

            if (wordCount > 1) {
                mainCategory = 'phrase';
            }

            const singleWord = words[0]?.toLowerCase();

            if (wordCount === 1 && singleWord) {
                if (!isNaN(parseFloat(singleWord)) && isFinite(singleWord)) {
                    subCategory = 'number';
                } else {
                    if (lang.startsWith('en')) {
                        if (singleWord.match(/^(is|am|are|was|were|be|have|has|had|do|does|did|will|can|could|may|might|should|would|go|get|say|see|make|know|take|come|think|look|want|give|use|find|tell|ask|work|seem|feel|try|leave|call)$/i)) subCategory = 'verb'; // Common verbs
                        else if (singleWord.endsWith('ing') || singleWord.endsWith('ed') || singleWord.endsWith('ize') || singleWord.endsWith('ate') || singleWord.endsWith('ify') || singleWord.endsWith('en')) subCategory = 'verb';
                        else if (singleWord.endsWith('tion') || singleWord.endsWith('sion') || singleWord.endsWith('ment') || singleWord.endsWith('ness') || singleWord.endsWith('ity') || singleWord.endsWith('er') || singleWord.endsWith('or') || singleWord.endsWith('ist') || singleWord.endsWith('ism') || singleWord.endsWith('age')) subCategory = 'noun';
                    } else if (lang.startsWith('fr')) {
                        if (singleWord.match(/^(être|avoir|faire|aller|pouvoir|vouloir|devoir|dire|voir|savoir|venir|falloir|croire|trouver|donner|parler|aimer|passer|mettre|demander|tenir|sembler|laisser|rester)$/i)) subCategory = 'verb';
                        else if (singleWord.endsWith('er') || singleWord.endsWith('ir') || singleWord.endsWith('re') || singleWord.endsWith('oir')) subCategory = 'verb';
                        else if (singleWord.endsWith('tion') || singleWord.endsWith('age') || singleWord.endsWith('ment') || singleWord.endsWith('isme') || singleWord.endsWith('eur') || singleWord.endsWith('euse') || singleWord.endsWith('té') || singleWord.endsWith('esse')) subCategory = 'noun';
                    } else if (lang.startsWith('tl')) {
                        if (singleWord.match(/^(um|mag|ma|mang|maki|nag|na|ini|ina|ika|ipa|ipang|ikapag)/i) || (singleWord.match(/(in|an)$/i) && !singleWord.match(/^(ka|pag|san|pan)/i)) ) subCategory = 'verb';
                        else if (singleWord.match(/^(pag|ka|tag|pala|sinta|taga|pang|pam|pan|sangka)/i) || (singleWord.endsWith('an') && singleWord.match(/^(ka|pag)/i))) subCategory = 'noun';
                        // Tagalog POS is very complex due to affixes and roots. This is extremely basic.
                    }
                }
            }
            // console.log(`Term: "${term}", Lang: ${lang}, MainCat: ${mainCategory}, SubCat: ${subCategory}`);
            return { mainCategory, subCategory };
        }


        // --- Audio and Speech ---
        function speakText(text, langCodeForTTS) { /* ... same ... */ return new Promise((resolve, reject) => { if (!text || !langCodeForTTS) { resolve(); return; } if ('speechSynthesis' in window) { if (ttsGeneralStatus) ttsGeneralStatus.textContent = ''; window.speechSynthesis.cancel(); const utterance = new SpeechSynthesisUtterance(text); utterance.lang = langCodeForTTS; utterance.onend = resolve; utterance.onerror = (e) => { console.error("SpeechSynthesisUtterance error:", e, "Text:", text, "Lang:", langCodeForTTS); if (ttsGeneralStatus) ttsGeneralStatus.textContent = `TTS error: ${e.error} for lang ${langCodeForTTS}`; reject(e); }; window.speechSynthesis.speak(utterance); } else { if (ttsGeneralStatus) ttsGeneralStatus.textContent = "Text-to-Speech not supported."; resolve(); } }); }
        function toggleHearItOutLoud() { /* ... same ... */ hearItOutLoudEnabled = !hearItOutLoudEnabled; updateHearItOutLoudButton(); if (mcqQuestion) mcqQuestion.classList.toggle('speakable-question', hearItOutLoudEnabled && !multipleChoiceGameContainer.classList.contains('hidden')); }
        function updateHearItOutLoudButton() { /* ... same ... */ if (hearItOutLoudToggleBtn && hearItOutLoudBtnText) { hearItOutLoudBtnText.textContent = `Hear: ${hearItOutLoudEnabled ? 'ON' : 'OFF'}`; hearItOutLoudToggleBtn.classList.toggle('active', hearItOutLoudEnabled); } }
        function initializeAudio() { /* ... same ... */ if (audioInitialized) return; Tone.start().then(() => { audioInitialized = true; backgroundMusicSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.2, release: 1 }, volume: -28 }).toDestination(); const vivaldiSpringMotif = [ { time: "0:0", note: "E4", duration: "4n" }, { time: "0:1", note: "E4", duration: "4n" }, { time: "0:2", note: "E4", duration: "4n" }, { time: "0:3", note: "C#5", duration: "4n" }, { time: "1:0", note: "D#5", duration: "4n" }, { time: "1:1", note: "D#5", duration: "4n" }, { time: "1:2", note: "D#5", duration: "4n" }, { time: "1:3", note: "B4", duration: "4n" }, { time: "2:0", note: "E4", duration: "4n" }, { time: "2:1", note: "E4", duration: "4n" }, { time: "2:2", note: "E4", duration: "4n" }, { time: "2:3", note: "C#5", duration: "4n" }, { time: "3:0", note: "D#5", duration: "4n" }, { time: "3:1", note: "D#5", duration: "4n" }, { time: "3:2", note: "B4", duration: "4n" }, { time: "3:3", note: "E4", duration: "4n" } ]; const musicPart = new Tone.Part((time, value) => backgroundMusicSynth.triggerAttackRelease(value.note, value.duration, time), vivaldiSpringMotif).start(0); musicPart.loop = true; musicPart.loopEnd = "4m"; correctMatchSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -12 }).toDestination(); incorrectBuzzSynth = new Tone.NoiseSynth ({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 }, volume: -18 }).toDestination(); notebookLostSynth = new Tone.MonoSynth({ oscillator: { type: "sawtooth" }, filter: { Q: 2, type: "lowpass", rolloff: -24 }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.3 }, filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.2, baseFrequency: 200, octaves: 2 }, volume: -15 }).toDestination(); updateMusicButton(); if(musicPlaying && Tone.Transport.state !== "started") Tone.Transport.start(); else if (!musicPlaying && Tone.Transport.state === "started") Tone.Transport.pause(); }).catch(e => console.error("Failed to start audio context:", e)); }
        function toggleMusic() { /* ... same ... */ if (!audioInitialized) { initializeAudio(); musicPlaying = !musicPlaying; return; } musicPlaying = !musicPlaying; if (musicPlaying && Tone.Transport.state !== "started") Tone.Transport.start(); else if (!musicPlaying && Tone.Transport.state === "started") Tone.Transport.pause(); updateMusicButton(); }
        function updateMusicButton() { /* ... same ... */ if (musicPlaying) { musicIconOn.classList.remove('hidden'); musicIconOff.classList.add('hidden'); musicStatusText.textContent = "Music: ON"; } else { musicIconOn.classList.add('hidden'); musicIconOff.classList.remove('hidden'); musicStatusText.textContent = "Music: OFF"; } }
        function playCorrectMatchSound() { /* ... same ... */ if (audioInitialized && correctMatchSynth) { correctMatchSynth.triggerAttackRelease("C5", "8n", Tone.now()); correctMatchSynth.triggerAttackRelease("G5", "4n", Tone.now() + 0.12); } }
        function playIncorrectSound() {  /* ... same ... */ if (audioInitialized && incorrectBuzzSynth) { incorrectBuzzSynth.triggerAttackRelease("0.2n"); } }
        function playNotebookLostSound() { /* ... same ... */ if (audioInitialized && notebookLostSynth) { notebookLostSynth.triggerAttackRelease("C3", "0.3n"); } }

        // --- Game State & Scoring ---
        function setupMistakeTracker() { /* ... same ... */ mistakeTrackerDiv.innerHTML = ''; for (let i = 0; i < MAX_MISTAKES; i++) { const capybaraSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg"); capybaraSvg.setAttribute("viewBox", "0 0 60 60"); capybaraSvg.setAttribute("fill", "currentColor"); capybaraSvg.classList.add("capybara-life-icon"); capybaraSvg.innerHTML = ` <path d="M30,15 C18,15 10,23 10,33 C10,43 15,50 22,52 C20,48 20,42 23,40 C25,38 28,38 30,39 C32,38 35,38 37,40 C40,42 40,48 38,52 C45,50 50,43 50,33 C50,23 42,15 30,15 Z M22,28 A2,2 0 0,1 24,30 A2,2 0 0,1 22,32 A2,2 0 0,1 20,30 A2,2 0 0,1 22,28 Z M38,28 A2,2 0 0,1 40,30 A2,2 0 0,1 38,32 A2,2 0 0,1 36,30 A2,2 0 0,1 38,28 Z M30,42 C28,42 27,41 27,40 C27,39 28,38 30,38 C32,38 33,39 33,40 C33,41 32,42 30,42 Z"></path> <ellipse cx="23" cy="25" rx="3" ry="2" fill="#4a2c2a"/> <ellipse cx="37" cy="25" rx="3" ry="2" fill="#4a2c2a"/> <path d="M28,33 Q30,35 32,33" stroke="#4a2c2a" stroke-width="1.5" fill="none" /> `; mistakeTrackerDiv.appendChild(capybaraSvg); } }
        function updateMistakeDisplay() { /* ... same ... */ const icons = mistakeTrackerDiv.querySelectorAll('.capybara-life-icon'); icons.forEach((icon, index) => { icon.classList.toggle('mistake', index < MAX_MISTAKES - mistakesRemaining); }); }
        function updateScoreDisplay() { /* ... same ... */ currentScoreDisplay.textContent = `Score: ${currentScore}`; maxScoreDisplay.textContent = `Max Score: ${sessionMaxScore}`; }
        function recordMistake(item = null) { /* ... same ... */ if (item && !isBonusRound && !isEssentialsMode) { if (!mistakeItems.find(mi => mi.originalIndex === item.originalIndex)) { mistakeItems.push(item); } } if (mistakesRemaining > 0) { mistakesRemaining--; playNotebookLostSound(); updateMistakeDisplay(); if (mistakesRemaining === 0 && !isBonusRound) { let restartFn = showGameSelection; if(!matchingGameContainer.classList.contains('hidden')) restartFn = () => initMatchingGame(false); else if(!multipleChoiceGameContainer.classList.contains('hidden')) restartFn = () => initMultipleChoiceGame(false); else if(!typeTranslationGameContainer.classList.contains('hidden')) restartFn = () => initTypeTranslationGame(false); else if(!talkToMeGameContainer.classList.contains('hidden')) restartFn = () => initTalkToMeGame(false); else if(!fillInTheBlanksGameContainer.classList.contains('hidden')) restartFn = () => initFillInTheBlanksGame(false); else if(!findTheWordsGameContainer.classList.contains('hidden')) restartFn = () => initFindTheWordsGame(); handleGameOver(restartFn); return true; } } return false; }

        function handleCorrectAnswer(isFast, item = null, points = null) {
            const pointsEarned = points !== null ? points : (isFast ? POINTS_FAST_CORRECT : POINTS_SLOW_CORRECT);
            currentScore += pointsEarned;
            if (activeGameType && sessionScores.hasOwnProperty(activeGameType)) {
                sessionScores[activeGameType] += pointsEarned;
            }

            if (currentScore > sessionMaxScore) sessionMaxScore = currentScore;
            updateScoreDisplay();
            playCorrectMatchSound();

            if (item && !isBonusRound) {
                const mainVocabList = isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName] : vocabulary;
                const vocabItemRef = mainVocabList.find(v => v.originalIndex === item.originalIndex);

                if (vocabItemRef) {
                    vocabItemRef.correctCount = (vocabItemRef.correctCount || 0) + 1;
                    console.log(`Item '${vocabItemRef.lang1}' (or target) correctCount: ${vocabItemRef.correctCount}`);
                }
                if (!isEssentialsMode) {
                     correctlyAnsweredItemsInPart.add(item.originalIndex);
                }
            }
        }
        function handleIncorrectAnswer(item = null, pointsDeducted = POINTS_INCORRECT) { /* ... same ... */ currentScore += pointsDeducted; if (currentScore < 0) currentScore = 0; if (activeGameType && sessionScores.hasOwnProperty(activeGameType)) { sessionScores[activeGameType] += pointsDeducted; if(sessionScores[activeGameType] < 0) sessionScores[activeGameType] = 0;} updateScoreDisplay(); playIncorrectSound(); return recordMistake(item); }
        function handleGameOver(gameSpecificRestartFn) { /* ... same ... */ gameOverMessage.textContent = "Game Over! Too many mistakes. Restarting this part..."; gameOverMessage.classList.remove('hidden'); disableAllGameInteractions(); setTimeout(() => { gameOverMessage.classList.add('hidden'); gameSpecificRestartFn(); }, 2500); }
        function disableAllGameInteractions() { /* ... same ... */ if(nextMcqBtn) nextMcqBtn.classList.add('hidden'); if (mcqOptions) mcqOptions.querySelectorAll('.mcq-option-btn').forEach(btn => btn.disabled = true); if (typeTranslationInput) typeTranslationInput.disabled = true; if (checkTypeTranslationBtn) checkTypeTranslationBtn.disabled = true; if (nextTypeTranslationBtn) nextTypeTranslationBtn.classList.add('hidden'); if (listenBtn) listenBtn.disabled = true; if (nextTalkToMeBtn) nextTalkToMeBtn.classList.add('hidden'); if (checkFillInTheBlanksBtn) checkFillInTheBlanksBtn.disabled = true; if (nextFillInTheBlanksBtn) nextFillInTheBlanksBtn.classList.add('hidden'); if (fillInTheBlanksInput) fillInTheBlanksInput.disabled = true; if (sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = true; if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = true; if (nextFindTheWordsRoundBtn) nextFindTheWordsRoundBtn.classList.add('hidden'); if (findTheWordsGrid) findTheWordsGrid.querySelectorAll('.game-card').forEach(card => card.style.pointerEvents = 'none'); }
        function resetSessionStats() { /* ... same ... */ currentScore = 0; mistakeItems = []; correctlyAnsweredItemsInPart.clear(); isBonusRound = false; resetGameStats(); if (activeGameType) sessionScores[activeGameType] = 0; }
        function resetGameStats() { /* ... same ... */ mistakesRemaining = MAX_MISTAKES; updateScoreDisplay(); setupMistakeTracker(); gameOverMessage.classList.add('hidden'); }
        function startQuestionTimer() { /* ... same ... */ questionStartTime = Date.now(); }
        function getAnswerDuration() { /* ... same ... */ return Date.now() - questionStartTime; }


        // --- Navigation and Setup ---
        function handleFileUpload() {
            const file = csvFileInput.files[0];
            if (!file) { /* ... no file ... */ uploadStatus.textContent = 'Please select a CSV file.'; uploadStatus.className = 'text-sm text-red-600 mt-2 h-5'; return; }
            if (targetLanguageSelector) {
                csvUploadedTargetLanguage = targetLanguageSelector.value;
                activeTargetStudyLanguage = csvUploadedTargetLanguage;
                console.log(`CSV Upload: csvUploadedTargetLanguage set to ${csvUploadedTargetLanguage}, activeTargetStudyLanguage set to ${activeTargetStudyLanguage}`);
            }
            isEssentialsMode = false; currentEssentialsCategoryName = "";
            const localReader = new FileReader();
            localReader.onload = function(event) {
                try {
                    parseCSV(event.target.result); // parseCSV now adds correctCount and categorizes
                    if (vocabulary.length > 0) { /* ... success ... */ uploadStatus.textContent = `Successfully loaded ${vocabulary.length} vocabulary pairs!`; uploadStatus.className = 'text-sm text-teal-600 mt-2 h-5'; currentVocabularyPart = [...vocabulary]; currentPartName = "Full List"; currentPartIndexGlobal = -1; uploadSection.classList.add('hidden'); showGameSelection(); }
                    else { /* ... no vocab ... */ uploadStatus.textContent = 'No vocabulary found. Ensure CSV has 2 columns & data after header.'; uploadStatus.className = 'text-sm text-red-600 mt-2 h-5';}
                } catch (error) { /* ... error ... */ uploadStatus.textContent = 'Error parsing CSV file. Please check format.'; uploadStatus.className = 'text-sm text-red-600 mt-2 h-5'; console.error("Error parsing CSV:", error); vocabulary = [];}
            };
            localReader.onerror = () => { uploadStatus.textContent = 'Error reading file.'; uploadStatus.className = 'text-sm text-red-600 mt-2 h-5'; };
            localReader.readAsText(file);
        }

        function parseCSV(csvData) {
            vocabulary = [];
            const lines = csvData.split(/\r\n|\n/).slice(1);
            lines.forEach((line, index) => {
                if (line.trim() === '') return;
                const parts = []; let currentPartText = ''; let inQuotes = false;
                for (let char of line) {
                    if (char === '"' && !currentPartText.endsWith('\\')) { inQuotes = !inQuotes; continue; }
                    if (char === ',' && !inQuotes) { parts.push(currentPartText.trim()); currentPartText = ''; }
                    else currentPartText += char;
                }
                parts.push(currentPartText.trim());
                const cleanedParts = parts.map(p => p.startsWith('"') && p.endsWith('"') ? p.substring(1, p.length - 1).replace(/""/g, '"') : p);

                if (cleanedParts.length >= 2 && cleanedParts[0] && cleanedParts[1]) {
                    const lang1Text = cleanedParts[0];
                    const lang2Text = cleanedParts[1];
                    const sentence = cleanedParts.length > 2 && cleanedParts[2] ? cleanedParts[2] : `This is a ____.`;
                    const { mainCategory, subCategory } = categorizeTerm(lang1Text, csvUploadedTargetLanguage);
                    vocabulary.push({
                        lang1: lang1Text, lang2: lang2Text, originalIndex: vocabulary.length,
                        category: mainCategory, subCategory: subCategory, sentence: sentence, correctCount: 0
                    });
                } else if (cleanedParts.length > 0 && !(cleanedParts.length === 1 && cleanedParts[0] === '')) {
                    console.warn(`Skipping line ${index + 2} due to incorrect format: "${line}"`, cleanedParts);
                }
            });
        }

        function showMainSelection() { /* ... same ... */ mainSelectionSection.classList.remove('hidden'); [uploadSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, gameSelectionSection, gameArea, partSelectionContainer].forEach(el => el.classList.add('hidden')); isEssentialsMode = false; currentEssentialsCategoryName = ""; sessionMaxScore = 0; updateScoreDisplay(); hearItOutLoudToggleBtn.classList.add('hidden'); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; activeTargetStudyLanguage = csvUploadedTargetLanguage; console.log("Main Selection: Active lang defaulted to CSV's: " + activeTargetStudyLanguage); }
        function populateEssentialsCategoryButtons() { /* ... same, sets activeTargetStudyLanguage based on categoryKey ... */ essentialsCategoryButtonsContainer.innerHTML = ''; Object.keys(essentialsVocabularyData).forEach(categoryKey => { const button = document.createElement('button'); button.className = 'btn essentials-category-btn p-4 text-md'; button.textContent = categoryKey; button.addEventListener('click', () => { currentEssentialsCategoryName = categoryKey; isEssentialsMode = true; if (categoryKey.toLowerCase().includes("(en-es)")) { activeTargetStudyLanguage = 'es-ES'; } else if (categoryKey.toLowerCase().includes("(en-fr)")) { activeTargetStudyLanguage = 'fr-FR'; } else { activeTargetStudyLanguage = 'en-US'; } console.log(`Essentials Category Clicked: ${categoryKey}. isEssentialsMode: ${isEssentialsMode}. activeTargetStudyLanguage set to: ${activeTargetStudyLanguage}`); currentVocabularyPart = essentialsVocabularyData[categoryKey].map((item, index) => ({...item, originalIndex: index, correctCount: item.correctCount || 0 })); essentialsOptionsTitle.textContent = `Category: ${categoryKey}`; essentialsCategorySelectionSection.classList.add('hidden'); essentialsCategoryOptionsSection.classList.remove('hidden'); }); essentialsCategoryButtonsContainer.appendChild(button); }); }
        function showGameSelection() { /* ... same, ensures activeTargetStudyLanguage is correct ... */ if (!isEssentialsMode) { activeTargetStudyLanguage = csvUploadedTargetLanguage; console.log("Show Game Selection (CSV Mode): Active lang set to CSV's: " + activeTargetStudyLanguage); } else { console.log("Show Game Selection (Essentials Mode): Active lang is: " + activeTargetStudyLanguage + " for category " + currentEssentialsCategoryName); } [mainSelectionSection, uploadSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, partSelectionContainer, gameArea].forEach(el => el.classList.add('hidden')); [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden')); gameSelectionSection.classList.remove('hidden'); fillInTheBlanksBtn.classList.toggle('hidden', !isEssentialsMode); findTheWordsBtn.classList.remove('hidden'); const activeVocab = isEssentialsMode ? currentVocabularyPart : vocabulary; if (activeVocab.length === 0) { noVocabularyMessage.classList.remove('hidden'); gameButtonsContainer.classList.add('hidden'); } else { noVocabularyMessage.classList.add('hidden'); gameButtonsContainer.classList.remove('hidden'); } sessionMaxScore = 0; updateScoreDisplay(); hearItOutLoudToggleBtn.classList.add('hidden'); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; }
        function showPartSelection(gameType) { /* ... same, ensures activeTargetStudyLanguage is correct ... */ if (!isEssentialsMode) { activeTargetStudyLanguage = csvUploadedTargetLanguage; console.log("Show Part Selection (CSV Mode): Active lang reset to CSV's: " + activeTargetStudyLanguage); } else { console.log("Show Part Selection (Essentials Mode): Active lang is: " + activeTargetStudyLanguage + " for category " + currentEssentialsCategoryName); } currentPartName = ""; sessionMaxScore = 0; updateScoreDisplay(); const sourceForParts = isEssentialsMode ? currentVocabularyPart : vocabulary; if (sourceForParts.length === 0) { noVocabularyMessage.classList.remove('hidden'); gameArea.classList.remove('hidden'); [partSelectionContainer, flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, gameOverMessage].forEach(el => el.classList.add('hidden')); hearItOutLoudToggleBtn.classList.add('hidden'); return; } gameTitle.textContent = gameType.charAt(0).toUpperCase() + gameType.slice(1).replace(/([A-Z])/g, ' $1'); [uploadSection, gameSelectionSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, mainSelectionSection].forEach(el => el.classList.add('hidden')); gameArea.classList.remove('hidden'); partSelectionContainer.classList.remove('hidden'); [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden')); showGameInfoBar(); const showHearButton = gameType === 'flashcards' || gameType === 'matching' || gameType === 'multipleChoice' || gameType === 'findTheWords'; hearItOutLoudToggleBtn.classList.toggle('hidden', !showHearButton); if(showHearButton) updateHearItOutLoudButton(); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; partButtonsContainer.innerHTML = ''; const numParts = Math.ceil(sourceForParts.length / ITEMS_PER_PART); const fullMixButton = document.createElement('button'); fullMixButton.className = 'btn part-selection-btn p-4 text-md'; let itemsForFullMixText = isEssentialsMode ? `${sourceForParts.length} items` : (gameType === 'matching' ? `${Math.min(MAX_GAME_ITEMS_MATCHING, sourceForParts.length)} pairs` : `${Math.min(MAX_GAME_ITEMS_MCQ, sourceForParts.length)} items`); if (gameType === 'typeTranslation' || gameType === 'flashcards' || gameType === 'talkToMe' || gameType === 'findTheWords') itemsForFullMixText = `${sourceForParts.length} items`; fullMixButton.textContent = `Full Mix (${itemsForFullMixText})`; fullMixButton.addEventListener('click', () => { currentVocabularyPart = [...sourceForParts]; currentPartName = "Full Mix"; currentPartIndexGlobal = -1; startGame(gameType); }); partButtonsContainer.appendChild(fullMixButton); if (numParts > 1 && sourceForParts.length > ITEMS_PER_PART) { for (let i = 0; i < numParts; i++) { const start = i * ITEMS_PER_PART; const end = start + ITEMS_PER_PART; const partVocab = sourceForParts.slice(start, end); if (partVocab.length === 0) continue; const button = document.createElement('button'); button.className = 'btn part-selection-btn p-4 text-md'; button.textContent = `Part ${i + 1} (Items ${start + 1}-${Math.min(end, sourceForParts.length)}) - ${partVocab.length} items`; button.addEventListener('click', () => { currentVocabularyPart = partVocab; currentPartName = `Part ${i + 1}`; currentPartIndexGlobal = i; startGame(gameType); }); partButtonsContainer.appendChild(button); } } }
        function startGame(gameType) {
            activeGameType = gameType; // Set current game type for scoring
            sessionScores[activeGameType] = 0; // Reset session score for this game
            console.log(`Starting Game: ${gameType}. isEssentialsMode: ${isEssentialsMode}. Active TTS/SR Lang: ${activeTargetStudyLanguage}`);
            console.log("Current vocabulary part for game (first 5):", currentVocabularyPart.slice(0,5).map(i => ({lang1: i.lang1, count: i.correctCount})));

            if (!audioInitialized) initializeAudio();
            if (musicPlaying && Tone.Transport.state !== "started" && audioInitialized) Tone.Transport.start();
            resetPartStats(); // Resets currentScore (for the round)

            if (!currentVocabularyPart || currentVocabularyPart.length === 0 ) { /* ... no vocab ... */ noVocabularyMessage.textContent = `No vocabulary for this game.`; noVocabularyMessage.classList.remove('hidden'); gameArea.classList.remove('hidden'); [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, partSelectionContainer].forEach(el => el.classList.add('hidden')); hearItOutLoudToggleBtn.classList.add('hidden'); return; }
            // ... rest of startGame UI setup ...
            noVocabularyMessage.classList.add('hidden'); [uploadSection, gameSelectionSection, partSelectionContainer, essentialsCategorySelectionSection, essentialsCategoryOptionsSection, mainSelectionSection].forEach(el => el.classList.add('hidden')); gameArea.classList.remove('hidden'); [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, flashcardStackSelectionContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden')); showGameInfoBar(); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; const showHearButton = gameType === 'flashcards' || gameType === 'matching' || gameType === 'multipleChoice' || gameType === 'findTheWords'; hearItOutLoudToggleBtn.classList.toggle('hidden', !showHearButton); if(showHearButton) updateHearItOutLoudButton(); const baseTitle = isEssentialsMode ? `${currentEssentialsCategoryName} - ` : (currentPartName ? `${currentPartName} - ` : 'Custom List - ');
            if (gameType === 'flashcards') { gameTitle.textContent = `${baseTitle}Flashcards`; flashcardGameContainer.classList.remove('hidden'); initFlashcards(currentVocabularyPart); }
            else if (gameType === 'matching') { gameTitle.textContent = `${baseTitle}Matching`; matchingGameContainer.classList.remove('hidden'); initMatchingGame(); }
            else if (gameType === 'multipleChoice') { gameTitle.textContent = `${baseTitle}Multiple Choice`; multipleChoiceGameContainer.classList.remove('hidden'); initMultipleChoiceGame(); }
            else if (gameType === 'typeTranslation') { gameTitle.textContent = `${baseTitle}Type Translation`; typeTranslationGameContainer.classList.remove('hidden'); initTypeTranslationGame(); }
            else if (gameType === 'talkToMe') { gameTitle.textContent = `${baseTitle}Talk to Me`; talkToMeGameContainer.classList.remove('hidden'); initTalkToMeGame(); }
            else if (gameType === 'fillInTheBlanks' && isEssentialsMode) { gameTitle.textContent = `${baseTitle}Fill in Blanks`; fillInTheBlanksGameContainer.classList.remove('hidden'); initFillInTheBlanksGame(); }
            else if (gameType === 'findTheWords') { gameTitle.textContent = `${baseTitle}Find the Words`; findTheWordsGameContainer.classList.remove('hidden'); initFindTheWordsGame(); }
        }
        function resetPartStats() { /* ... same, but currentScore is for the round ... */ currentScore = 0; if (!isEssentialsMode) { mistakeItems = []; correctlyAnsweredItemsInPart.clear(); } isBonusRound = false; mistakesRemaining = MAX_MISTAKES; updateScoreDisplay(); setupMistakeTracker(); gameOverMessage.classList.add('hidden'); if (activeGameType) sessionScores[activeGameType] = 0; }
        function showFlashcardStackSelection() { /* ... same, ensures activeTargetStudyLanguage ... */ if (!isEssentialsMode) { activeTargetStudyLanguage = csvUploadedTargetLanguage; } const sourceForStacks = isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName] : vocabulary; if (sourceForStacks.length === 0) { initFlashcards([]); gameTitle.textContent = 'Flashcards'; [uploadSection, gameSelectionSection, mainSelectionSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection].forEach(el => el.classList.add('hidden')); gameArea.classList.remove('hidden'); flashcardGameContainer.classList.remove('hidden'); flashcardStackSelectionContainer.classList.add('hidden'); document.getElementById('gameInfoBar').classList.add('hidden'); hearItOutLoudToggleBtn.classList.add('hidden'); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; return; } gameTitle.textContent = 'Flashcards - Select Stack'; [uploadSection, gameSelectionSection, mainSelectionSection, essentialsCategorySelectionSection, essentialsCategoryOptionsSection].forEach(el => el.classList.add('hidden')); gameArea.classList.remove('hidden'); flashcardStackSelectionContainer.classList.remove('hidden'); [flashcardGameContainer, matchingGameContainer, multipleChoiceGameContainer, typeTranslationGameContainer, talkToMeGameContainer, fillInTheBlanksGameContainer, findTheWordsGameContainer, partSelectionContainer, gameOverMessage, roundCompleteMessageDiv, bonusRoundCountdownMessageDiv].forEach(el => el.classList.add('hidden')); document.getElementById('gameInfoBar').classList.add('hidden'); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton(); if(ttsGeneralStatus) ttsGeneralStatus.textContent = ''; stackButtonsContainer.innerHTML = ''; const categories = { 'All Vocabulary': sourceForStacks, 'Words': sourceForStacks.filter(v => v.category === 'word'), 'Phrasal Verbs': sourceForStacks.filter(v => v.category === 'phrasal verb'), 'Expressions': sourceForStacks.filter(v => v.category === 'expression') }; for (const [name, stack] of Object.entries(categories)) { if (stack.length > 0 || name === 'All Vocabulary') { const button = document.createElement('button'); button.className = 'btn stack-selection-btn p-4 text-md'; button.textContent = `${name} (${stack.length})`; button.addEventListener('click', () => { flashcardStackSelectionContainer.classList.add('hidden'); flashcardGameContainer.classList.remove('hidden'); gameTitle.textContent = `Flashcards - ${name}`; showGameInfoBar(); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton(); initFlashcards(stack); }); stackButtonsContainer.appendChild(button); } } }
        function showGameInfoBar() { /* ... same ... */ const el = document.getElementById('gameInfoBar'); if(el) el.classList.remove('hidden');}

        // --- Game Logic: Flashcards ---
        function initFlashcards(stackToUse) { /* ... same ... */ currentFlashcardStack = stackToUse ? shuffleArray([...stackToUse]) : []; currentFlashcardIndex = 0; currentFlashcardSide = 'front'; if (currentFlashcardStack.length > 0) displayFlashcard(); else { flashcardFront.textContent = 'No vocabulary in this stack.'; flashcardBack.textContent = ''; flashcardCounter.textContent = '0/0'; prevCardBtn.disabled = true; nextCardBtn.disabled = true; } }
        function displayFlashcard() { /* ... same, uses activeTargetStudyLanguage for TTS ... */ if (currentFlashcardStack.length === 0 || currentFlashcardIndex < 0 || currentFlashcardIndex >= currentFlashcardStack.length) { flashcardFront.textContent = 'End of stack.'; flashcardBack.textContent = ''; return; } const item = currentFlashcardStack[currentFlashcardIndex]; const { target, translation } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); flashcardFront.textContent = truncateText(target); flashcardFront.title = target; flashcardBack.textContent = truncateText(translation); flashcardBack.title = translation; if (currentFlashcardSide === 'front') { flashcardFront.classList.remove('hidden'); flashcardBack.classList.add('hidden'); if (hearItOutLoudEnabled && target) speakText(target, activeTargetStudyLanguage); } else { flashcardFront.classList.add('hidden'); flashcardBack.classList.remove('hidden'); } flashcardCounter.textContent = `${currentFlashcardIndex + 1} / ${currentFlashcardStack.length}`; prevCardBtn.disabled = currentFlashcardIndex === 0; nextCardBtn.disabled = currentFlashcardIndex === currentFlashcardStack.length - 1; }
        function flipFlashcard() { /* ... same ... */ if (currentFlashcardStack.length === 0) return; currentFlashcardSide = (currentFlashcardSide === 'front') ? 'back' : 'front'; displayFlashcard(); }
        function nextFlashcard() { /* ... same ... */ if (currentFlashcardIndex < currentFlashcardStack.length - 1) { currentFlashcardIndex++; currentFlashcardSide = 'front'; displayFlashcard(); } }
        function prevFlashcard() { /* ... same ... */ if (currentFlashcardIndex > 0) { currentFlashcardIndex--; currentFlashcardSide = 'front'; displayFlashcard(); } }

        // --- Game Logic: Matching ---
        let matchingGameActiveVocab = []; let selectedMatchCard = null; let matchedPairs = 0; let pairsToMatch = 0;
        function initMatchingGame(isBonus = false) {
            showGameInfoBar(); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton();
            let sourceVocabForThisGame = isBonus ? mistakeItems : currentVocabularyPart;
            let availableItems = sourceVocabForThisGame.filter(vItem => (vItem.correctCount || 0) < LEARNED_THRESHOLD_GAMES);

            if (!isBonus && availableItems.length === 0 && sourceVocabForThisGame.length > 0) {
                if (window.confirm(`You've mastered all terms in this set for Matching/MCQ! Restart learning this set? (Resets learned counts for these items).`)) {
                    sourceVocabForThisGame.forEach(vResetItem => {
                        const mainVocabItem = vocabulary.find(v => v.originalIndex === vResetItem.originalIndex) || (isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName]?.find(v => v.originalIndex === vResetItem.originalIndex) : null);
                        if (mainVocabItem) mainVocabItem.correctCount = 0;
                    });
                    availableItems = [...sourceVocabForThisGame];
                } else { showGameSelection(); return; }
            } else if (availableItems.length === 0 && !isBonus) { // No items to play even after potential reset or if list was empty
                 matchingInstructions.textContent = 'No items available for this game or all learned and not restarted.';
                 matchingGrid.innerHTML = '';
                 if (!isBonus && !isEssentialsMode) proceedToNextPartOrEnd('matching', currentPartIndexGlobal);
                 else if (isEssentialsMode && !isBonus) handleRoundComplete('matching');
                 return;
            }


            if (!isBonus) {
                isBonusRound = false;
                matchingGameActiveVocab = shuffleArray([...availableItems]).slice(0, MAX_GAME_ITEMS_MATCHING);
            } else {
                isBonusRound = true; matchingGameActiveVocab = shuffleArray([...sourceVocabForThisGame]); // Bonus uses all mistake items
                gameTitle.textContent = `Matching - Bonus Round!`;
            }
            resetGameStats(); /* ... rest of initMatchingGame ... */ matchingGrid.innerHTML = ''; matchingFeedback.textContent = ''; selectedMatchCard = null; matchedPairs = 0; if (matchingGameActiveVocab.length === 0) { matchingInstructions.textContent = isBonus ? 'No mistakes to practice!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!'); if (!isBonus && !isEssentialsMode) proceedToNextPartOrEnd('matching', currentPartIndexGlobal); else if (isEssentialsMode && !isBonus) handleRoundComplete('matching'); return; } pairsToMatch = matchingGameActiveVocab.length; const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Selection"); matchingInstructions.textContent = `${isBonus ? 'Bonus Round:' : `Part: ${partInfo}`} Match Target Language to Your Language. (${pairsToMatch} pairs)`; const targetLangCards = matchingGameActiveVocab.map((pair) => { const { target } = getEffectiveLanguages(pair, isEssentialsMode, activeTargetStudyLanguage); return { id: `target-${pair.originalIndex}`, text: target, type: 'target', pairId: pair.originalIndex, item: pair }; }); const translationLangCards = matchingGameActiveVocab.map((pair) => { const { translation } = getEffectiveLanguages(pair, isEssentialsMode, activeTargetStudyLanguage); return { id: `translation-${pair.originalIndex}`, text: translation, type: 'translation', pairId: pair.originalIndex, item: pair }; }); const allCards = shuffleArray([...targetLangCards, ...translationLangCards]); allCards.forEach(cardData => { const cardElement = document.createElement('div'); cardElement.className = 'card game-card p-2 sm:p-4 text-sm sm:text-base h-24 sm:h-28'; cardElement.textContent = truncateText(cardData.text); cardElement.title = cardData.text; cardElement.dataset.id = cardData.id; cardElement.dataset.type = cardData.type; cardElement.dataset.pairId = cardData.pairId; cardElement.addEventListener('click', handleMatchCardClick); matchingGrid.appendChild(cardElement); }); startQuestionTimer();
        }
        function handleMatchCardClick(event) { /* ... same, uses activeTargetStudyLanguage for TTS ... */ const clickedCard = event.currentTarget; if (hearItOutLoudEnabled && !clickedCard.classList.contains('matched') && clickedCard.dataset.type === 'target') { const textToSpeak = clickedCard.title; if (textToSpeak) speakText(textToSpeak, activeTargetStudyLanguage); } if (mistakesRemaining === 0 && !isBonusRound) return; if (clickedCard.classList.contains('matched')) return; if (!selectedMatchCard) { clickedCard.classList.add('selected-match'); selectedMatchCard = clickedCard; matchingFeedback.textContent = ''; } else { if (selectedMatchCard === clickedCard) { selectedMatchCard.classList.remove('selected-match'); selectedMatchCard = null; return; } if (selectedMatchCard.dataset.type === clickedCard.dataset.type) { selectedMatchCard.classList.remove('selected-match'); clickedCard.classList.add('selected-match'); selectedMatchCard = clickedCard; matchingFeedback.textContent = 'Select one of each language type.'; matchingFeedback.className = 'text-center font-medium mt-4 h-6 text-orange-500'; return; } const duration = getAnswerDuration(); const itemForMistake = matchingGameActiveVocab.find(v => v.originalIndex === parseInt(selectedMatchCard.dataset.pairId)); if (selectedMatchCard.dataset.pairId === clickedCard.dataset.pairId) { handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, itemForMistake); selectedMatchCard.classList.add('matched'); clickedCard.classList.add('matched'); selectedMatchCard.classList.remove('selected-match'); matchingFeedback.textContent = 'Correct Match!'; matchingFeedback.className = 'text-center font-medium mt-4 h-6 text-emerald-600'; selectedMatchCard = null; matchedPairs++; if (matchedPairs === pairsToMatch) { if (isBonusRound) { roundCompleteMessageDiv.innerHTML = `Bonus Round Complete! <br> Score for ${currentPartName || currentEssentialsCategoryName}: ${currentScore}`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('matching', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000); } else handleRoundComplete('matching'); } else startQuestionTimer(); } else { const gameOver = handleIncorrectAnswer(itemForMistake); matchingFeedback.textContent = 'Incorrect. Try again.'; matchingFeedback.className = 'text-center font-medium mt-4 h-6 text-red-500'; selectedMatchCard.classList.add('incorrect-match-animation'); clickedCard.classList.add('incorrect-match-animation'); setTimeout(() => { if(selectedMatchCard) selectedMatchCard.classList.remove('incorrect-match-animation', 'selected-match'); clickedCard.classList.remove('incorrect-match-animation'); selectedMatchCard = null; if (gameOver && !isBonusRound) { /* already handled */ } else startQuestionTimer(); }, 500); } } }

        // --- Game Logic: Multiple Choice ---
        let mcqGameActiveVocab = [];
        function initMultipleChoiceGame(isBonus = false) {
            showGameInfoBar(); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton();
            if(mcqQuestion) mcqQuestion.classList.toggle('speakable-question', hearItOutLoudEnabled);
            let sourceVocabForThisGame = isBonus ? mistakeItems : currentVocabularyPart;
            let availableItems = sourceVocabForThisGame.filter(vItem => (vItem.correctCount || 0) < LEARNED_THRESHOLD_GAMES);

            if (!isBonus && availableItems.length === 0 && sourceVocabForThisGame.length > 0) {
                if (window.confirm(`You've mastered all terms in this set for Matching/MCQ! Restart learning this set? (Resets learned counts for these items).`)) {
                    sourceVocabForThisGame.forEach(vResetItem => {
                        const mainVocabItem = vocabulary.find(v => v.originalIndex === vResetItem.originalIndex) || (isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName]?.find(v => v.originalIndex === vResetItem.originalIndex) : null);
                        if (mainVocabItem) mainVocabItem.correctCount = 0;
                    });
                    availableItems = [...sourceVocabForThisGame];
                } else { showGameSelection(); return; }
            } else if (availableItems.length === 0 && !isBonus) {
                mcqInstructions.textContent = 'No items available or all learned and not restarted.'; mcqQuestion.textContent = ''; mcqOptions.innerHTML = '';
                if (!isBonus && !isEssentialsMode) proceedToNextPartOrEnd('multipleChoice', currentPartIndexGlobal);
                else if (isEssentialsMode && !isBonus) handleRoundComplete('multipleChoice');
                return;
            }

            if (!isBonus) { /* ... non-bonus setup ... */ isBonusRound = false; mcqGameActiveVocab = shuffleArray([...availableItems]).slice(0, MAX_GAME_ITEMS_MCQ); }
            else { /* ... bonus setup ... */ isBonusRound = true; mcqGameActiveVocab = shuffleArray([...sourceVocabForThisGame]); gameTitle.textContent = `MCQ - Bonus Round!`; }
            resetGameStats(); /* ... rest of init ... */ currentMcqIndex = 0; mcqAnswered = false; nextMcqBtn.classList.add('hidden'); mcqFeedback.textContent = ''; if (mcqGameActiveVocab.length === 0) { mcqQuestion.textContent = isBonus ? 'No mistakes to practice!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!'); if(mcqOptions) mcqOptions.innerHTML = ''; if (!isBonus && !isEssentialsMode) proceedToNextPartOrEnd('multipleChoice', currentPartIndexGlobal); else if (isEssentialsMode && !isBonus) handleRoundComplete('multipleChoice'); return; } const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List"); mcqInstructions.textContent = `${isBonus ? 'Bonus:' : `Part: ${partInfo}`} Choose the correct Translation for the Target Language word. (${mcqGameActiveVocab.length} questions)`; displayMcq();
        }
        function displayMcq() { /* ... same, uses activeTargetStudyLanguage for TTS ... */ mcqAnswered = false; nextMcqBtn.classList.add('hidden'); mcqFeedback.textContent = ''; mcqOptions.innerHTML = ''; if(mcqQuestion) mcqQuestion.classList.toggle('speakable-question', hearItOutLoudEnabled); if (currentMcqIndex >= mcqGameActiveVocab.length) { if (isBonusRound) { roundCompleteMessageDiv.innerHTML = `Bonus Round Complete! <br> Score for ${currentPartName || currentEssentialsCategoryName}: ${currentScore}`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('multipleChoice', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000); } else { handleRoundComplete('multipleChoice'); } return; } if (mistakesRemaining === 0 && !isBonusRound) return; const currentPair = mcqGameActiveVocab[currentMcqIndex]; const { target, translation } = getEffectiveLanguages(currentPair, isEssentialsMode, activeTargetStudyLanguage); mcqQuestion.textContent = truncateText(target); mcqQuestion.title = target; if (hearItOutLoudEnabled && target) speakText(target, activeTargetStudyLanguage); const correctAnswer = translation; let options = [correctAnswer]; const allPossibleTranslations = (isEssentialsMode ? Object.values(essentialsVocabularyData).flat().map(p => getEffectiveLanguages(p, true, activeTargetStudyLanguage).translation) : vocabulary.map(p => p.lang2) ).filter(t => t !== undefined && t !== null && typeof t === 'string'); const distractors = shuffleArray(allPossibleTranslations.filter(text => text.toLowerCase() !== correctAnswer.toLowerCase())).slice(0, 3); options.push(...distractors); while (options.length < Math.min(2, allPossibleTranslations.length) && options.length < 4) options.push(`Option ${options.length + 1}`); options = shuffleArray(options.slice(0,4)); options.forEach(optionText => { const optionButton = document.createElement('button'); optionButton.className = 'btn mcq-option-btn'; optionButton.textContent = truncateText(optionText); optionButton.title = optionText; optionButton.addEventListener('click', () => handleMcqAnswer(optionText, correctAnswer, optionButton, currentPair)); mcqOptions.appendChild(optionButton); }); mcqInstructions.textContent = `Question ${currentMcqIndex + 1}/${mcqGameActiveVocab.length}. Choose translation for: ${truncateText(target)}`; startQuestionTimer(); }
        function handleMcqAnswer(selectedAnswer, correctAnswer, buttonElement, item) { /* ... same ... */ if (mcqAnswered || (mistakesRemaining === 0 && !isBonusRound)) return; mcqAnswered = true; const duration = getAnswerDuration(); mcqOptions.querySelectorAll('.mcq-option-btn').forEach(btn => { btn.disabled = true; if (btn.title.toLowerCase() === correctAnswer.toLowerCase()) { btn.classList.add('correct-answer'); } }); if (buttonElement.title.toLowerCase() === correctAnswer.toLowerCase()) { handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, item); mcqFeedback.textContent = 'Correct!'; mcqFeedback.className = 'text-center font-medium mt-4 h-6 text-emerald-600'; if (currentMcqIndex >= mcqGameActiveVocab.length - 1) { nextMcqBtn.classList.remove('hidden'); } else { setTimeout(() => { nextMcqQuestion(); }, 1500); } } else { const gameOver = handleIncorrectAnswer(item); mcqFeedback.textContent = `Incorrect. The answer was: ${truncateText(correctAnswer)}`; mcqFeedback.title = `Full answer: ${correctAnswer}`; mcqFeedback.className = 'text-center font-medium mt-4 h-6 text-red-500'; buttonElement.classList.add('incorrect-answer'); nextMcqBtn.classList.remove('hidden'); if (gameOver && !isBonusRound) { /* Game over handled */ } } }
        function nextMcqQuestion() { /* ... same ... */ if (mistakesRemaining === 0 && !isBonusRound) { initMultipleChoiceGame(false); return; } currentMcqIndex++; if (mcqOptions) mcqOptions.querySelectorAll('.mcq-option-btn').forEach(btn => btn.disabled = false); displayMcq(); }

        // --- Game Logic: Type Translation ---
        let typeTransGameActiveVocab = [];
        function initTypeTranslationGame(isBonus = false) { /* ... uses currentVocabularyPart ... */ showGameInfoBar(); hearItOutLoudToggleBtn.classList.add('hidden'); let sourceVocabForThisGame = isBonus ? mistakeItems : currentVocabularyPart; if (!isBonus) { isBonusRound = false; typeTransGameActiveVocab = shuffleArray([...sourceVocabForThisGame]); } else { isBonusRound = true; typeTransGameActiveVocab = shuffleArray([...sourceVocabForThisGame]); gameTitle.textContent = `Type Translation - Bonus Round!`; } resetPartStats(); currentTypeTranslationIndex = 0; typeTranslationAnswered = false; hintUsedForCurrentTypeTranslation = false; nextTypeTranslationBtn.classList.add('hidden'); typeTranslationFeedback.textContent = ''; typeTranslationInput.value = ''; typeTranslationInput.disabled = false; checkTypeTranslationBtn.disabled = false; hintTypeTranslationBtn.disabled = false; typeTranslationHintDisplay.textContent = ''; if (typeTransGameActiveVocab.length === 0) { typeTranslationPhrase.textContent = isBonus ? 'No mistakes to practice!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!'); typeTranslationCounter.textContent = '0/0'; if (!isBonus && !isEssentialsMode) proceedToNextPartOrEnd('typeTranslation', currentPartIndexGlobal); else if (isEssentialsMode && !isBonus) handleRoundComplete('typeTranslation'); return; } const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List"); typeTranslationInstructions.textContent = `${isBonus ? 'Bonus:' : `Part: ${partInfo}`} Type Target Language translation for word/phrase shown. (${typeTransGameActiveVocab.length} items)`; displayTypeTranslationQuestion(); }
        function displayTypeTranslationQuestion() { /* ... same, uses activeTargetStudyLanguage ... */ typeTranslationAnswered = false; hintUsedForCurrentTypeTranslation = false; nextTypeTranslationBtn.classList.add('hidden'); typeTranslationInput.value = ''; typeTranslationInput.disabled = false; checkTypeTranslationBtn.disabled = false; hintTypeTranslationBtn.disabled = false; typeTranslationHintDisplay.textContent = ''; typeTranslationFeedback.textContent = ''; typeTranslationInput.focus(); if (currentTypeTranslationIndex >= typeTransGameActiveVocab.length) { if (isBonusRound) { roundCompleteMessageDiv.innerHTML = `Bonus Round Complete! <br> Score for ${currentPartName || currentEssentialsCategoryName}: ${currentScore}`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); isBonusRound = false; mistakeItems = []; if (!isEssentialsMode) proceedToNextPartOrEnd('typeTranslation', currentPartIndexGlobalForBonusReturn); else showGameSelection(); }, 3000); } else { handleRoundComplete('typeTranslation'); } return; } if (mistakesRemaining === 0 && !isBonusRound) return; const pair = typeTransGameActiveVocab[currentTypeTranslationIndex]; const { translation } = getEffectiveLanguages(pair, isEssentialsMode, activeTargetStudyLanguage); typeTranslationPhrase.textContent = truncateText(translation); typeTranslationPhrase.title = translation; typeTranslationCounter.textContent = `${currentTypeTranslationIndex + 1} / ${typeTransGameActiveVocab.length}`; startQuestionTimer(); }
        function showTypeTranslationHint() { /* ... same, uses activeTargetStudyLanguage ... */ if (typeTranslationAnswered || hintUsedForCurrentTypeTranslation || currentTypeTranslationIndex >= typeTransGameActiveVocab.length) return; const { target } = getEffectiveLanguages(typeTransGameActiveVocab[currentTypeTranslationIndex], isEssentialsMode, activeTargetStudyLanguage); const correctAnswer = target.trim(); if (correctAnswer.length > 0) { typeTranslationHintDisplay.textContent = `Hint: Starts with "${correctAnswer[0]}"`; hintUsedForCurrentTypeTranslation = true; hintTypeTranslationBtn.disabled = true; } }
        function checkTypeTranslationAnswer() { /* ... same, uses activeTargetStudyLanguage ... */ if (typeTranslationAnswered || (mistakesRemaining === 0 && !isBonusRound) || currentTypeTranslationIndex >= typeTransGameActiveVocab.length) return; const duration = getAnswerDuration(); const userAnswer = typeTranslationInput.value.trim().toLowerCase(); const currentItem = typeTransGameActiveVocab[currentTypeTranslationIndex]; const { target } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); const correctAnswer = target.trim().toLowerCase(); typeTranslationAnswered = true; typeTranslationInput.disabled = true; checkTypeTranslationBtn.disabled = true; hintTypeTranslationBtn.disabled = true; nextTypeTranslationBtn.classList.remove('hidden'); nextTypeTranslationBtn.focus(); if (userAnswer === correctAnswer) { handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, currentItem); typeTranslationFeedback.textContent = 'Correct!'; typeTranslationFeedback.className = 'text-center font-medium mt-4 h-6 text-emerald-600'; typeTranslationInput.classList.add('border-emerald-500'); typeTranslationInput.classList.remove('border-red-500'); } else { const gameOver = handleIncorrectAnswer(currentItem); typeTranslationFeedback.textContent = `Not quite. Correct: ${target}`; typeTranslationFeedback.className = 'text-center font-medium mt-4 h-6 text-red-500'; typeTranslationInput.classList.add('border-red-500'); typeTranslationInput.classList.remove('border-emerald-500'); if (gameOver && !isBonusRound) { /* handled */ } } }
        function nextTypeTranslationQuestion() { /* ... same ... */ if (mistakesRemaining === 0 && !isBonusRound) { initTypeTranslationGame(false); return; } currentTypeTranslationIndex++; typeTranslationInput.classList.remove('border-red-500', 'border-emerald-500'); displayTypeTranslationQuestion(); }

        // --- Game Logic: Fill In The Blanks (Essentials Mode Only) ---
        function initFillInTheBlanksGame() { /* ... same ... */ if (!isEssentialsMode) { fillInTheBlanksSentence.textContent = "This game is available for 'Study Essentials' only."; disableAllGameInteractions(); return; } showGameInfoBar(); hearItOutLoudToggleBtn.classList.add('hidden'); isBonusRound = false; fillBlanksGameActiveVocab = shuffleArray([...currentVocabularyPart]) .filter(item => item.sentence && item.sentence.includes("____")) .slice(0, MAX_GAME_ITEMS_FILL_BLANKS); resetGameStats(); setupMistakeTracker(); currentFillBlanksIndex = 0; fillBlanksAnswered = false; nextFillInTheBlanksBtn.classList.add('hidden'); fillInTheBlanksFeedback.textContent = ''; fillInTheBlanksInput.value = ''; fillInTheBlanksInput.disabled = false; checkFillInTheBlanksBtn.disabled = false; if (fillBlanksGameActiveVocab.length === 0) { fillInTheBlanksSentence.textContent = `No "fill in the blank" items in ${currentEssentialsCategoryName}. Sentences must contain '____'.`; fillInTheBlanksCounter.textContent = '0/0'; handleRoundComplete('fillInTheBlanks'); return; } fillInTheBlanksInstructions.textContent = `Part: ${currentEssentialsCategoryName}. Fill in the blank. (${fillBlanksGameActiveVocab.length} items)`; displayFillInTheBlanksQuestion(); }
        function displayFillInTheBlanksQuestion() { /* ... same, uses activeTargetStudyLanguage ... */ fillBlanksAnswered = false; nextFillInTheBlanksBtn.classList.add('hidden'); fillInTheBlanksInput.value = ''; fillInTheBlanksInput.disabled = false; checkFillInTheBlanksBtn.disabled = false; fillInTheBlanksFeedback.textContent = ''; fillInTheBlanksInput.focus(); if (currentFillBlanksIndex >= fillBlanksGameActiveVocab.length) { handleRoundComplete('fillInTheBlanks'); return; } if (mistakesRemaining === 0) return; const currentItem = fillBlanksGameActiveVocab[currentFillBlanksIndex]; const { target: blankWordForSentence } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); const sentenceParts = currentItem.sentence.split("____"); fillInTheBlanksSentence.innerHTML = ''; fillInTheBlanksSentence.appendChild(document.createTextNode(sentenceParts[0])); const blankPlaceholder = document.createElement('span'); blankPlaceholder.className = 'blank-placeholder'; blankPlaceholder.textContent = '(blank)'; fillInTheBlanksSentence.appendChild(blankPlaceholder); if (sentenceParts.length > 1) fillInTheBlanksSentence.appendChild(document.createTextNode(sentenceParts[1])); fillInTheBlanksSentence.dataset.fullSentence = currentItem.sentence; fillInTheBlanksSentence.dataset.blankWord = blankWordForSentence; fillInTheBlanksCounter.textContent = `${currentFillBlanksIndex + 1} / ${fillBlanksGameActiveVocab.length}`; startQuestionTimer(); }
        function checkFillInTheBlanksAnswer() { /* ... same, uses activeTargetStudyLanguage ... */ if (fillBlanksAnswered || mistakesRemaining === 0 || currentFillBlanksIndex >= fillBlanksGameActiveVocab.length) return; const duration = getAnswerDuration(); const userAnswer = fillInTheBlanksInput.value.trim().toLowerCase(); const currentItem = fillBlanksGameActiveVocab[currentFillBlanksIndex]; const { target: correctAnswer } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); const correctAnswerLower = correctAnswer.trim().toLowerCase(); fillBlanksAnswered = true; fillInTheBlanksInput.disabled = true; checkFillInTheBlanksBtn.disabled = true; nextFillInTheBlanksBtn.classList.remove('hidden'); nextFillInTheBlanksBtn.focus(); if (userAnswer === correctAnswerLower) { handleCorrectAnswer(duration <= FAST_ANSWER_THRESHOLD, currentItem); fillInTheBlanksFeedback.textContent = 'Correct!'; fillInTheBlanksFeedback.className = 'text-center font-medium mt-4 h-6 text-emerald-600'; fillInTheBlanksInput.classList.add('border-emerald-500'); fillInTheBlanksInput.classList.remove('border-red-500'); } else { const gameOver = handleIncorrectAnswer(currentItem); fillInTheBlanksFeedback.textContent = `Not quite. Correct answer: ${correctAnswer}`; fillInTheBlanksFeedback.className = 'text-center font-medium mt-4 h-6 text-red-500'; fillInTheBlanksInput.classList.add('border-red-500'); fillInTheBlanksInput.classList.remove('border-emerald-500'); if (gameOver) { /* handled */ } } }
        function nextFillInTheBlanksQuestion() { /* ... same ... */ if (mistakesRemaining === 0) { initFillInTheBlanksGame(); return; } currentFillBlanksIndex++; fillInTheBlanksInput.classList.remove('border-red-500', 'border-emerald-500'); displayFillInTheBlanksQuestion(); }

        // --- Game Logic: Find The Words ---
        function initFindTheWordsGame() { /* ... uses currentVocabularyPart ... */ showGameInfoBar(); hearItOutLoudToggleBtn.classList.remove('hidden'); updateHearItOutLoudButton(); const sourceVocabForThisGame = currentVocabularyPart; if (sourceVocabForThisGame.length < FIND_WORDS_REQUIRED_VOCAB) { findTheWordsGrid.innerHTML = `<p class="col-span-full text-center text-red-500">Not enough vocabulary for 'Find the Words' (need at least ${FIND_WORDS_REQUIRED_VOCAB} unique target language items).</p>`; disableAllGameInteractions(); return; } findWordsSessionVocab = shuffleArray([...sourceVocabForThisGame]).slice(0, FIND_WORDS_REQUIRED_VOCAB * 2); resetGameStats(); setupMistakeTracker(); currentFindWordsRound = 0; findWordsSelectedWords = []; nextFindTheWordsRoundBtn.classList.add('hidden'); sendFindTheWordsBtn.disabled = true; findTheWordsFeedback.textContent = ''; replayFindTheWordsAudioBtn.disabled = false; const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List"); gameTitle.textContent = `${partInfo} - Find the Words`; displayFindTheWordsQuestion(); }
        async function speakFindTheWordsTargets(wordsToSpeakArray, initialDelay = 1000) { /* ... uses activeTargetStudyLanguage ... */ if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = true; if (initialDelay > 0) await new Promise(resolve => setTimeout(resolve, initialDelay)); try { for (let i = 0; i < wordsToSpeakArray.length; i++) { const item = wordsToSpeakArray[i]; const { target: textToSpeak } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); if (textToSpeak) await speakText(textToSpeak, activeTargetStudyLanguage); if (i < wordsToSpeakArray.length - 1) await new Promise(resolve => setTimeout(resolve, 750)); } } catch (error) { console.error("Error in speakFindTheWordsTargets:", error); if(ttsGeneralStatus) ttsGeneralStatus.textContent = "Audio error."; } finally { if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = false; } }
        function displayFindTheWordsQuestion() {
            // Skip items mastered (correctCount >= MASTERED_THRESHOLD_SPEAK_LISTEN)
            let initialRoundIndex = currentFindWordsRound * WORDS_PER_FIND_WORDS_TARGET;
            let actualTargets = [];
            let tempSessionVocab = findWordsSessionVocab.filter(item => (item.correctCount || 0) < MASTERED_THRESHOLD_SPEAK_LISTEN);

            if (tempSessionVocab.length < WORDS_PER_FIND_WORDS_TARGET) {
                 findTheWordsGrid.innerHTML = `<p class="col-span-full text-center text-red-500">Not enough unmastered words for a full round. Game ending.</p>`;
                 setTimeout(() => handleRoundComplete('findTheWords'), 2500);
                 return;
            }
            findWordsTargetWords = shuffleArray(tempSessionVocab).slice(0, WORDS_PER_FIND_WORDS_TARGET);


            findWordsSelectedWords = []; /* ... rest of displayFindTheWordsQuestion ... */ if(findTheWordsGrid) findTheWordsGrid.innerHTML = ''; if(sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = true; if(nextFindTheWordsRoundBtn) nextFindTheWordsRoundBtn.classList.add('hidden'); if(findTheWordsFeedback) findTheWordsFeedback.textContent = ''; if(replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = false; if (currentFindWordsRound >= MAX_FIND_WORDS_ROUNDS) { handleRoundComplete('findTheWords'); return; } if(findTheWordsInstructions) findTheWordsInstructions.textContent = `Listen and select the ${WORDS_PER_FIND_WORDS_TARGET} words you hear (in the Target Language).`; if(findTheWordsRoundCounter) findTheWordsRoundCounter.textContent = `Round: ${currentFindWordsRound + 1}/${MAX_FIND_WORDS_ROUNDS}`; const sourceForDistractors = currentVocabularyPart; let remainingVocabForDistractors = shuffleArray([...sourceForDistractors].filter(item => !findWordsTargetWords.some(target => target.originalIndex === item.originalIndex) )); const distractors = remainingVocabForDistractors.slice(0, WORDS_PER_FIND_WORDS_DISPLAY - WORDS_PER_FIND_WORDS_TARGET); findWordsCurrentChoices = shuffleArray([...findWordsTargetWords, ...distractors]); findWordsCurrentChoices.forEach(wordObj => { const cardElement = document.createElement('div'); cardElement.className = 'card game-card p-2 sm:p-4 text-sm sm:text-base h-24 sm:h-28'; const { target: displayText } = getEffectiveLanguages(wordObj, isEssentialsMode, activeTargetStudyLanguage); cardElement.textContent = truncateText(displayText); cardElement.title = displayText; cardElement.dataset.word = displayText; cardElement.addEventListener('click', handleFindWordCardClick); if(findTheWordsGrid) findTheWordsGrid.appendChild(cardElement); }); speakFindTheWordsTargets(findWordsTargetWords, 1000); startQuestionTimer();
        }
        function handleFindWordCardClick(event) { /* ... same ... */ if (findTheWordsFeedback && (findTheWordsFeedback.textContent.includes("Correct") || findTheWordsFeedback.textContent.includes("Incorrect"))) { return; } const cardElement = event.currentTarget; const word = cardElement.dataset.word; if (cardElement.classList.contains('selected-find-word')) { cardElement.classList.remove('selected-find-word'); findWordsSelectedWords = findWordsSelectedWords.filter(sw => sw !== word); } else { if (findWordsSelectedWords.length < WORDS_PER_FIND_WORDS_TARGET) { cardElement.classList.add('selected-find-word'); findWordsSelectedWords.push(word); } } if (sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = findWordsSelectedWords.length !== WORDS_PER_FIND_WORDS_TARGET; }
        function checkFindTheWordsAnswer() { /* ... same, uses activeTargetStudyLanguage ... */ if (findWordsSelectedWords.length !== WORDS_PER_FIND_WORDS_TARGET) return; if (replayFindTheWordsAudioBtn) replayFindTheWordsAudioBtn.disabled = true; if (sendFindTheWordsBtn) sendFindTheWordsBtn.disabled = true; const sortedSelected = [...findWordsSelectedWords].sort((a,b) => a.localeCompare(b, activeTargetStudyLanguage, { sensitivity: 'base' })); const sortedTargets = findWordsTargetWords.map(w => { const { target } = getEffectiveLanguages(w, isEssentialsMode, activeTargetStudyLanguage); return target; }).sort((a,b) => a.localeCompare(b, activeTargetStudyLanguage, { sensitivity: 'base' })); let isCorrect = sortedSelected.length === sortedTargets.length && sortedSelected.every((value, index) => value.toLowerCase() === sortedTargets[index].toLowerCase()); if (isCorrect) { findWordsTargetWords.forEach(item => handleCorrectAnswer(false, item, POINTS_SLOW_CORRECT / findWordsTargetWords.length)); if (findTheWordsFeedback) { findTheWordsFeedback.textContent = 'Correct!'; findTheWordsFeedback.className = 'text-center font-medium mt-4 h-6 text-emerald-600'; } } else { handleIncorrectAnswer(null, POINTS_INCORRECT); if (findTheWordsFeedback) { findTheWordsFeedback.textContent = 'Incorrect. Try the next round.'; findTheWordsFeedback.className = 'text-center font-medium mt-4 h-6 text-red-500'; } } if (nextFindTheWordsRoundBtn) { nextFindTheWordsRoundBtn.classList.remove('hidden'); if (currentFindWordsRound + 1 >= MAX_FIND_WORDS_ROUNDS) { nextFindTheWordsRoundBtn.textContent = "Finish Game"; } else { nextFindTheWordsRoundBtn.textContent = "Next Round"; } } }
        function nextFindTheWordsRound() { /* ... same ... */ currentFindWordsRound++; if (currentFindWordsRound >= MAX_FIND_WORDS_ROUNDS) { handleRoundComplete('findTheWords'); } else { displayFindTheWordsQuestion(); } }

        // --- Game Logic: Talk to Me ---
        let talkToMeActiveVocab = [];
        function initTalkToMeGame(isBonus = false) { /* ... uses currentVocabularyPart ... */ showGameInfoBar(); hearItOutLoudToggleBtn.classList.add('hidden'); let sourceVocabForThisGame = isBonus ? mistakeItems : currentVocabularyPart; if (!isBonus) { isBonusRound = false; talkToMeActiveVocab = shuffleArray([...sourceVocabForThisGame]).filter(item => (item.correctCount || 0) < MASTERED_THRESHOLD_SPEAK_LISTEN).slice(0, MAX_GAME_ITEMS_MCQ); if(talkToMeActiveVocab.length === 0 && sourceVocabForThisGame.length > 0) { if(window.confirm("You've mastered all phrases for Talk To Me in this set! Restart learning this set? (Resets learned counts).")) { sourceVocabForThisGame.forEach(vResetItem => { const mainV = vocabulary.find(v=>v.originalIndex === vResetItem.originalIndex) || (isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName]?.find(v=>v.originalIndex === vResetItem.originalIndex):null); if(mainV) mainV.correctCount = 0; }); talkToMeActiveVocab = shuffleArray([...sourceVocabForThisGame]).slice(0, MAX_GAME_ITEMS_MCQ); } else { showGameSelection(); return; } } } else { isBonusRound = true; talkToMeActiveVocab = shuffleArray([...sourceVocabForThisGame]); gameTitle.textContent = `Talk to Me - Bonus Round!`; } resetPartStats(); currentTalkToMeIndex = 0; attemptCountForCurrentTalkToMeItem = 0; isListening = false; if(listenBtnText) listenBtnText.textContent = 'Start Listening'; if(listenBtn) { listenBtn.classList.remove('listening', 'btn-danger'); listenBtn.classList.add('btn-primary'); listenBtn.disabled = false; } if(nextTalkToMeBtn) nextTalkToMeBtn.classList.add('hidden'); if(talkToMeFeedback) talkToMeFeedback.textContent = ''; if(talkToMeRecognizedText) talkToMeRecognizedText.textContent = '...'; if(talkToMeReferenceContainer) talkToMeReferenceContainer.classList.add('hidden'); if(speechApiStatus) speechApiStatus.textContent = ''; if (talkToMeActiveVocab.length === 0) { talkToMePhraseText.textContent = isBonus ? 'No mistakes to practice!' : (isEssentialsMode ? `All items in ${currentEssentialsCategoryName} learned!` : 'All items in this part learned or no items available!'); talkToMeCounter.textContent = '0/0'; if (!isBonus && !isEssentialsMode) proceedToNextPartOrEnd('talkToMe', currentPartIndexGlobal); else if (isEssentialsMode && !isBonus) handleRoundComplete('talkToMe'); return; } const partInfo = isEssentialsMode ? currentEssentialsCategoryName : (currentPartName || "Custom List"); if(talkToMeInstructions) talkToMeInstructions.textContent = `${isBonus ? 'Bonus:' : `Part: ${partInfo}`} Read the Target Language phrase aloud. (${talkToMeActiveVocab.length} items)`; setupSpeechRecognition(); displayTalkToMeItem(); }
        function displayTalkToMeItem() {
            // Skip mastered items
            while (currentTalkToMeIndex < talkToMeActiveVocab.length && (talkToMeActiveVocab[currentTalkToMeIndex].correctCount || 0) >= MASTERED_THRESHOLD_SPEAK_LISTEN) {
                currentTalkToMeIndex++;
            }

            if (currentTalkToMeIndex >= talkToMeActiveVocab.length) {
                 if (talkToMeActiveVocab.every(item => (item.correctCount || 0) >= MASTERED_THRESHOLD_SPEAK_LISTEN) && talkToMeActiveVocab.length > 0) {
                    if (window.confirm("You've mastered all phrases in this Talk to Me session! Restart this set? (Resets 'learned' counts for these items).")) {
                        talkToMeActiveVocab.forEach(vResetItem => {
                            const mainVocabItem = vocabulary.find(v => v.originalIndex === vResetItem.originalIndex) || (isEssentialsMode ? essentialsVocabularyData[currentEssentialsCategoryName]?.find(v => v.originalIndex === vResetItem.originalIndex) : null);
                            if (mainVocabItem) mainVocabItem.correctCount = 0;
                        });
                    }
                 }
                handleRoundComplete('talkToMe'); return;
            }
            /* ... rest of displayTalkToMeItem, uses activeTargetStudyLanguage ... */ if (mistakesRemaining === 0 && !isBonusRound) return; attemptCountForCurrentTalkToMeItem = 0; const item = talkToMeActiveVocab[currentTalkToMeIndex]; const { target, translation } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); if(talkToMePhraseText) talkToMePhraseText.textContent = target; if(talkToMePhraseToRead) talkToMePhraseToRead.title = target; if(talkToMeReferenceDisplay) talkToMeReferenceDisplay.textContent = translation; if(talkToMeReferenceLabel) talkToMeReferenceLabel.textContent = isEssentialsMode ? (activeTargetStudyLanguage.startsWith('es') ? 'English Original:' : 'Spanish Translation:') : 'Your Language Translation:'; if(talkToMeReferenceContainer) talkToMeReferenceContainer.classList.add('hidden'); if(talkToMeRecognizedText) talkToMeRecognizedText.textContent = '...'; if(talkToMeFeedback) talkToMeFeedback.textContent = ''; if(listenBtn) listenBtn.disabled = false; if(nextTalkToMeBtn) nextTalkToMeBtn.classList.add('hidden'); if(talkToMeCounter) talkToMeCounter.textContent = `${currentTalkToMeIndex + 1} / ${talkToMeActiveVocab.length}`; startQuestionTimer();
        }
        function setupSpeechRecognition() { /* ... same, uses activeTargetStudyLanguage ... */ const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition; if (!SpeechRecognitionAPI) { if(speechApiStatus) speechApiStatus.textContent = "Speech API not supported."; if(listenBtn) listenBtn.disabled = true; return; } recognition = new SpeechRecognitionAPI(); recognition.lang = activeTargetStudyLanguage; recognition.interimResults = false; recognition.maxAlternatives = 1; recognition.onresult = (event) => { const spokenText = event.results[event.results.length - 1][0].transcript.trim(); if(talkToMeRecognizedText) talkToMeRecognizedText.textContent = spokenText; processSpokenText(spokenText); }; recognition.onerror = (event) => { if(speechApiStatus) speechApiStatus.textContent = `Recognition error: ${event.error}`; console.error("Speech error:", event.error, "Lang:", recognition.lang); if (isListening && typeof toggleListeningSpeechUIUpdate === "function") toggleListeningSpeechUIUpdate(false);}; recognition.onend = () => { if (isListening && typeof toggleListeningSpeechUIUpdate === "function") toggleListeningSpeechUIUpdate(false);}; }
        function toggleListeningSpeech() { /* ... same, uses activeTargetStudyLanguage ... */ if (!recognition) { if (speechApiStatus) speechApiStatus.textContent = "Speech recognition not initialized."; return; } if (isListening) { recognition.stop(); } else { try { recognition.lang = activeTargetStudyLanguage; recognition.start(); toggleListeningSpeechUIUpdate(true); } catch (e) { console.error("Error starting recognition:", e); if (speechApiStatus) speechApiStatus.textContent = "Could not start listening. Try again."; toggleListeningSpeechUIUpdate(false); } } }
        function toggleListeningSpeechUIUpdate(nowListening) { /* ... same ... */ isListening = nowListening; if (listenBtn && listenBtnText) { if (isListening) { listenBtnText.textContent = 'Stop Listening'; listenBtn.classList.add('listening', 'btn-danger'); listenBtn.classList.remove('btn-primary'); if (talkToMeFeedback) talkToMeFeedback.textContent = "Speak now..."; if (talkToMeRecognizedText) talkToMeRecognizedText.textContent = "..."; } else { listenBtnText.textContent = 'Start Listening'; listenBtn.classList.remove('listening', 'btn-danger'); listenBtn.classList.add('btn-primary'); } } }
        function processSpokenText(spokenText) { /* ... same, uses activeTargetStudyLanguage ... */ if ((mistakesRemaining === 0 && !isBonusRound) || currentTalkToMeIndex >= talkToMeActiveVocab.length) return; attemptCountForCurrentTalkToMeItem++; const currentItem = talkToMeActiveVocab[currentTalkToMeIndex]; const { target: targetTextForComparisonOriginal } = getEffectiveLanguages(currentItem, isEssentialsMode, activeTargetStudyLanguage); let targetTextForComparison = targetTextForComparisonOriginal.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g,"").replace(/\s{2,}/g," ").trim(); const recognizedNormalized = spokenText.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g,"").replace(/\s{2,}/g," ").trim(); const targetWordsSet = new Set(targetTextForComparison.split(" ").filter(w => w.length > 0)); const recognizedWordsSet = new Set(recognizedNormalized.split(" ").filter(w => w.length > 0)); let matchingWords = 0; recognizedWordsSet.forEach(word => { if (targetWordsSet.has(word)) matchingWords++; }); const similarity = targetWordsSet.size > 0 ? (matchingWords / targetWordsSet.size) : (recognizedNormalized === "" && targetTextForComparison === "" ? 1 : 0); if(talkToMeReferenceContainer) talkToMeReferenceContainer.classList.remove('hidden'); if (similarity > 0.75) { handleCorrectAnswer(false, currentItem, POINTS_CORRECT_TALK_TO_ME); if (talkToMeFeedback) { talkToMeFeedback.textContent = "Great! That sounds right."; talkToMeFeedback.className = 'text-center font-medium mt-3 h-6 text-emerald-600'; } if (nextTalkToMeBtn) nextTalkToMeBtn.classList.remove('hidden'); if (listenBtn) listenBtn.disabled = true; } else if (similarity > 0.5) { if (talkToMeFeedback) { talkToMeFeedback.textContent = "Almost! Try focusing on clear enunciation and try again."; talkToMeFeedback.className = 'text-center font-medium mt-3 h-6 text-amber-600'; } if (attemptCountForCurrentTalkToMeItem >= 2 && !isBonusRound) { const gameOver = handleIncorrectAnswer(currentItem, 0); if (gameOver) {} } if (nextTalkToMeBtn) nextTalkToMeBtn.classList.remove('hidden'); if (listenBtn) listenBtn.disabled = false; } else { if (talkToMeFeedback) { talkToMeFeedback.textContent = "Not quite. Listen to the pronunciation and try again."; talkToMeFeedback.className = 'text-center font-medium mt-3 h-6 text-red-500'; } if (attemptCountForCurrentTalkToMeItem >= 2 && !isBonusRound) { const gameOver = handleIncorrectAnswer(currentItem); if (gameOver) {} } if (nextTalkToMeBtn) nextTalkToMeBtn.classList.remove('hidden'); if (listenBtn) listenBtn.disabled = false; } }
        function speakCurrentTalkToMePhrase() { /* ... same, uses activeTargetStudyLanguage ... */ if (currentTalkToMeIndex >= talkToMeActiveVocab.length) return; const item = talkToMeActiveVocab[currentTalkToMeIndex]; const { target: phraseToSpeak } = getEffectiveLanguages(item, isEssentialsMode, activeTargetStudyLanguage); if (phraseToSpeak) speakText(phraseToSpeak, activeTargetStudyLanguage); }
        function nextTalkToMeItem() { /* ... same ... */ if (mistakesRemaining === 0 && !isBonusRound) { initTalkToMeGame(false); return; } currentTalkToMeIndex++; displayTalkToMeItem(); }

        // --- Round Completion and Bonus ---
        function handleRoundComplete(gameType) {
            disableAllGameInteractions();
            const roundName = isEssentialsMode ? currentEssentialsCategoryName : currentPartName;
            if (activeGameType && gameScores.hasOwnProperty(activeGameType)) {
                gameScores[activeGameType] += currentScore; // Add current round's score to overall game type score
            }
            console.log("Overall Game Scores:", JSON.parse(JSON.stringify(gameScores))); // Log a copy
            console.log("Session Scores for this part:", JSON.parse(JSON.stringify(sessionScores)));

            roundCompleteMessageDiv.innerHTML = `${roundName || 'Game'} Complete! <br> Score for this round: ${currentScore} <br> Max Session Score: ${sessionMaxScore}`;
            roundCompleteMessageDiv.classList.remove('hidden');
            currentPartIndexGlobalForBonusReturn = currentPartIndexGlobal;
            setTimeout(() => { /* ... same timeout logic ... */ roundCompleteMessageDiv.classList.add('hidden'); if (mistakeItems.length > 0 && !isBonusRound && !isEssentialsMode && gameType !== 'findTheWords' && gameType !== 'fillInTheBlanks') { startBonusRoundCountdown(gameType); } else if (isEssentialsMode || gameType === 'findTheWords' || gameType === 'fillInTheBlanks') { showGameSelection(); } else { proceedToNextPartOrEnd(gameType, currentPartIndexGlobal); } }, 3000);
        }
        function proceedToNextPartOrEnd(gameType, completedPartIndex) { /* ... same ... */ mistakeItems = []; isBonusRound = false; if (currentPartName === "Full Mix" || completedPartIndex === -1 || isEssentialsMode) { showGameSelection(); return; } const nextPartIndex = completedPartIndex + 1; const nextPartStartIndex = nextPartIndex * ITEMS_PER_PART; if (nextPartStartIndex < vocabulary.length) { currentPartIndexGlobal = nextPartIndex; currentVocabularyPart = vocabulary.slice(nextPartStartIndex, nextPartStartIndex + ITEMS_PER_PART); currentPartName = `Part ${nextPartIndex + 1}`; resetPartStats(); startGame(gameType); } else { roundCompleteMessageDiv.innerHTML = `All CSV Parts Completed! <br> Final Max Score: ${sessionMaxScore}`; roundCompleteMessageDiv.classList.remove('hidden'); setTimeout(() => { roundCompleteMessageDiv.classList.add('hidden'); showGameSelection(); }, 3000); } }
        function startBonusRoundCountdown(gameType) { /* ... same ... */ if (isEssentialsMode || gameType === 'findTheWords' || gameType === 'fillInTheBlanks') return; bonusRoundCountdownMessageDiv.classList.remove('hidden'); let countdown = 3; bonusRoundCountdownMessageDiv.textContent = `Bonus Round in ${countdown}...`; const interval = setInterval(() => { countdown--; if (countdown > 0) { bonusRoundCountdownMessageDiv.textContent = `Bonus Round in ${countdown}...`; } else { clearInterval(interval); bonusRoundCountdownMessageDiv.classList.add('hidden'); if (gameType === 'matching') initMatchingGame(true); else if (gameType === 'multipleChoice') initMultipleChoiceGame(true); else if (gameType === 'typeTranslation') initTypeTranslationGame(true); else if (gameType === 'talkToMe') initTalkToMeGame(true); } }, 1000); }

        // Event Listeners
        musicToggleBtn.addEventListener('click', toggleMusic);
        showUploadSectionBtn.addEventListener('click', () => { mainSelectionSection.classList.add('hidden'); uploadSection.classList.remove('hidden'); isEssentialsMode = false; activeTargetStudyLanguage = csvUploadedTargetLanguage; console.log("Upload Section Shown: isEssentialsMode=false. Active lang reverted to CSV's: " + activeTargetStudyLanguage); });
        showEssentialsSectionBtn.addEventListener('click', () => { mainSelectionSection.classList.add('hidden'); essentialsCategorySelectionSection.classList.remove('hidden'); isEssentialsMode = true; populateEssentialsCategoryButtons(); console.log("Essentials Section Shown: isEssentialsMode=true."); });
        backToMainSelectionFromUploadBtn.addEventListener('click', () => { uploadSection.classList.add('hidden'); mainSelectionSection.classList.remove('hidden'); isEssentialsMode = false; activeTargetStudyLanguage = csvUploadedTargetLanguage; console.log("Back to Main from Upload: Active lang is CSV's: " + activeTargetStudyLanguage); });
        backToMainSelectionFromEssentialsBtn.addEventListener('click', () => { essentialsCategorySelectionSection.classList.add('hidden'); mainSelectionSection.classList.remove('hidden'); isEssentialsMode = false; activeTargetStudyLanguage = csvUploadedTargetLanguage; console.log("Back to Main from Essentials Select: Active lang is CSV's: " + activeTargetStudyLanguage); });
        backToEssentialsCategoriesBtn.addEventListener('click', () => { essentialsCategoryOptionsSection.classList.add('hidden'); essentialsCategorySelectionSection.classList.remove('hidden'); });
        reviewEssentialsCategoryBtn.addEventListener('click', () => { essentialsCategoryOptionsSection.classList.add('hidden'); gameArea.classList.remove('hidden'); startGame('flashcards'); });
        playGamesWithEssentialsBtn.addEventListener('click', () => { essentialsCategoryOptionsSection.classList.add('hidden'); showGameSelection(); });
        uploadBtn.addEventListener('click', handleFileUpload);
        flashcardsBtn.addEventListener('click', () => { initializeAudio(); showFlashcardStackSelection(); });
        matchingBtn.addEventListener('click', () => { initializeAudio(); showPartSelection('matching'); });
        multipleChoiceBtn.addEventListener('click', () => { initializeAudio(); showPartSelection('multipleChoice'); });
        typeTranslationBtn.addEventListener('click', () => { initializeAudio(); showPartSelection('typeTranslation'); });
        talkToMeBtn.addEventListener('click', () => { initializeAudio(); showPartSelection('talkToMe'); });
        fillInTheBlanksBtn.addEventListener('click', () => { initializeAudio(); startGame('fillInTheBlanks'); });
        findTheWordsBtn.addEventListener('click', () => { initializeAudio(); startGame('findTheWords'); });
        backToGameSelectionBtn.addEventListener('click', showGameSelection);
        backToSourceSelectionBtn.addEventListener('click', () => { gameSelectionSection.classList.add('hidden'); if (isEssentialsMode) { essentialsCategoryOptionsSection.classList.remove('hidden'); console.log("Back to Essentials Options: Active lang is Essentials': " + activeTargetStudyLanguage); } else { uploadSection.classList.remove('hidden'); activeTargetStudyLanguage = csvUploadedTargetLanguage; console.log("Back to Upload Section from CSV game selection: Active lang reset to CSV's: " + activeTargetStudyLanguage); } });
        flashcardDiv.addEventListener('click', flipFlashcard);
        nextCardBtn.addEventListener('click', nextFlashcard);
        prevCardBtn.addEventListener('click', prevFlashcard);
        if(resetCurrentPartBtn) resetCurrentPartBtn.addEventListener('click', () => { if(!matchingGameContainer.classList.contains('hidden')) initMatchingGame(false); else if(!multipleChoiceGameContainer.classList.contains('hidden')) initMultipleChoiceGame(false); else if(!typeTranslationGameContainer.classList.contains('hidden')) initTypeTranslationGame(false); else if(!talkToMeGameContainer.classList.contains('hidden')) initTalkToMeGame(false); else if(!fillInTheBlanksGameContainer.classList.contains('hidden')) initFillInTheBlanksGame(false); else if(!findTheWordsGameContainer.classList.contains('hidden')) initFindTheWordsGame(); });
        nextMcqBtn.addEventListener('click', nextMcqQuestion);
        if (mcqQuestion) mcqQuestion.addEventListener('click', () => { if (hearItOutLoudEnabled && mcqGameActiveVocab.length > 0 && currentMcqIndex < mcqGameActiveVocab.length) { const currentPairForTTS = mcqGameActiveVocab[currentMcqIndex]; const { target: questionText } = getEffectiveLanguages(currentPairForTTS, isEssentialsMode, activeTargetStudyLanguage); if (questionText) speakText(questionText, activeTargetStudyLanguage); } });
        checkTypeTranslationBtn.addEventListener('click', checkTypeTranslationAnswer);
        nextTypeTranslationBtn.addEventListener('click', nextTypeTranslationQuestion);
        hintTypeTranslationBtn.addEventListener('click', showTypeTranslationHint);
        typeTranslationInput.addEventListener('keypress', (e) => { if (e.key === "Enter") { e.preventDefault(); if (!typeTranslationAnswered) checkTypeTranslationAnswer(); else if (mistakesRemaining > 0) nextTypeTranslationQuestion(); }});
        checkFillInTheBlanksBtn.addEventListener('click', checkFillInTheBlanksAnswer);
        nextFillInTheBlanksBtn.addEventListener('click', nextFillInTheBlanksQuestion);
        fillInTheBlanksInput.addEventListener('keypress', (e) => { if (e.key === "Enter") { e.preventDefault(); if (!fillBlanksAnswered) checkFillInTheBlanksAnswer(); else if (mistakesRemaining > 0) nextFillInTheBlanksQuestion(); }});
        replayFindTheWordsAudioBtn.addEventListener('click', () => speakFindTheWordsTargets(findWordsTargetWords, 0));
        sendFindTheWordsBtn.addEventListener('click', checkFindTheWordsAnswer);
        nextFindTheWordsRoundBtn.addEventListener('click', nextFindTheWordsRound);
        listenBtn.addEventListener('click', toggleListeningSpeech);
        nextTalkToMeBtn.addEventListener('click', nextTalkToMeItem);
        speakPhraseBtn.addEventListener('click', speakCurrentTalkToMePhrase);
        hearItOutLoudToggleBtn.addEventListener('click', toggleHearItOutLoud);

        // Initial Setup
        showMainSelection(); updateMusicButton(); setupMistakeTracker(); updateScoreDisplay(); updateHearItOutLoudButton();
    </script>
</body>
</html>
